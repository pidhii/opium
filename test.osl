
println(list([1,2,3,4].iter()))

println("iterate over list")
for x in [1, 2, 3, 4, 5] do
  println("-", x)

println("iterate over vector")
vec = vector([1, 2, 3, 4].iter())
vec.push(5)
for x in vec do
  println("vec -", x)


require "subprocess"
for line in run("ls -lrth")#stdout.lines() do
  println(line)


require "dict"
dd = dict()
set dd["one"] = 1
println(dd["one"])
set dd["two"] = 2
for key, val in dd do
  println("dd[", key, "] = ", val)


require "trie"
d = trie()
set d = d.insert("one", 1)
println(d["one"])


require "json"
let j = open("test.json", "r").read_json() in
println(dict(j))


println("testing regex")
re = regexp("([a-z]+)([0-9]+)")
ms = "___adfasd12312".find(re)
for m in *ms do {
  if bool(m) then
    println("- ", m)
}

require "argv"
my_option = ""
my_flag = false
options = [
  option("my-option")
  .docstring("the command-line argument")
  .required(true)
  .value(true)
  .handle(x => set my_option = x)
  ,
  option("my-flag")
  .docstring("the flag")
  .handle(x => set my_flag = true)
]
posargs = getopt(["--my-option=42", "--my-option=foo", "--my-flag", "42", "15"], options)
println("my_option =", my_option)
println("my_flag =", my_flag)
println("posargs =", posargs)

// require "zmq"

// type message = {
//   message str,
// }

// message(j json) = message(j["message"].str())
// json(msg message) = {
//   struct = dict()
//   set struct["message"] = JsonString(msg#message)
//   return JsonStructure(struct)
// }

// ctx = zmq_context(1)
// sock = ctx.socket(zmq_rep)
// sock.bind("tcp://*:4444")
// request = sock.receive().expect("Failed to receive a request").str().parse_json()
// println("request.message:", message(request)#message)
// response = call_with_output_string(port => writejson(message("Hi there!").json(), port))
// println("response:", response)
// sock.send(response)


type foobar = Foo | Bar
foo = Foo
match foo in
| Foo -> println("This is foo")
| Bar -> println("This is bar")


println("c,compile".split(r"\w+"))


if let hd : tl = [1, 2, 3] then
  println("head: ", hd, ", tail: ", tl)


blb = blob(64)
println("blb: ", blb)
set blb#u16[0] = 0xBEAF
println("blb: ", blb)


case 1 + 2 in 
| 1 -> println("one")
| 2 -> println("two")
| 3 -> println("three")
| 4 -> println("four")
| otherwize -> println("idk")


println("test division: ", 4 / 2 / 2)

let x = 1 in
println("test unary: ", -x < 0)

extern identifier!(list->string) as listtostr(list(char)) -> str
println("list->string: ", listtostr(["a"[0], "b"[0]]))
// println("list->string: ", identifier!(list->string)(["a"[0], "b"[0]]))

type one = One
{
  tup = pack(1, "one", One)
  println("tup: ", tup)
  let t1, t2, t3 = unpack(tup) in
  println(t1, " ", t2, " ", t3)
}