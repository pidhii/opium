
println(list([1,2,3,4].iter()))

println("iterate over list")
for x in [1, 2, 3, 4, 5] do
  println("-", x)

println("iterate over vector")
vec = vector([1, 2, 3, 4].iter())
vec.push(5)
for x in vec do
  println("vec -", x)


require "subprocess"
for line in run("ls -lrth")#out.lines() do
  println(line)


require "dict"
dd = dict()
set dd["one"] = 1
println(dd["one"])
set dd["two"] = 2
for key, val in dd do
  println("dd[", key, "] = ", val)


require "trie"
d = trie()
set d = d.insert("one", 1)
println(d["one"])


require "json"
println("JSON:")
let j = open("test.json", "r").readjson() in {
  println("j[one] = ", jsonref(j, "one"))
  println("j[two] = ", jsonref(j, "two"))
  println("j[two][2] = ", jsonref(j, "two").jsonref(2))
}
assert { 42 :: json }
assert { array([1::json, "42"::json, 3::json]) :: json }
let s = "whatever" :: (num or str) in
assert { s :: json }


println("testing regex")
re = regexp("([a-z]+)([0-9]+)")
let s =  "___adfasd12312" in 
if let Some(m) = s.find(re) then {
  for i in 0 : 3 do
    let start, end = unpack(*m.indices(i)) in
    println("  match #", i, " = ", s[start : end])
}

type foobar = Foo | Bar
foo = Foo
match foo in
| Foo -> println("This is foo")
| Bar -> println("This is bar")


println("c,compile".split(","))


if let hd : tl = [1, 2, 3] then
  println("head: ", hd, ", tail: ", tl)


blb = blob(64)
println("blb: ", blb)
set blb#u16[0] = 0xBEAF
println("blb: ", blb)


case 1 + 2 in 
| 1 -> println("one")
| 2 -> println("two")
| 3 -> println("three")
| 4 -> println("four")
| otherwize -> println("idk")


println("test division: ", 4 / 2 / 2)

let x = 1 in
println("test unary: ", -x < 0)

type one = One | Two
tup = pack(1, "one", One)
println("tup: ", tup)
let t1, t2, t3 = unpack(tup) in
println(t1, " ", t2, " ", t3)


test_null(x str?) =
  println("test_null: bool(", x, ") = ", bool(x))
test_null("not-null")
test_null(null)

println(format("~S", "ĸ•⌚⏪"))

{ if true then "something" } :: str?

test_inline_scm() = {
  println("before")
  scm { print }(1, 2, 3)
  println("after")
}
test_inline_scm()


for x, y in [1, 2, 3], [3, 2, 1] do
  println("- ", x, " ", y)


propcond1 = condition("propcond1", "p1", 1, "p2", 2)
println("propcond1: ", propcond1)

propcond2 = condition("propcond2", "p3", 3)
compcond1 = propcond1 + propcond2
println("compcond1: ", compcond1)

propcond3 = condition("propcond3", "p4", 4)
compcond2 = compcond1 + propcond3
println("compcond2: ", compcond2)

println("test condpredicate: ", condpredicate("propcond2")(compcond2) :: bool)

try 1 / 0 catch exn
| net_error, arithmetic_error -> { println("network arithmetics error!?: ", exn) 0 }
| system_error, arithmetic_error -> { println("arithmetic error: ", what(exn)) 0 }
| system_error -> { println("system error: ", exn) 0 }


test_return_from_loop() = {
  for i in 0 : 10 do
    if i > 5 then
      return "yey", 1
  return "ney", 2
}
println("test_return_from_loop", test_return_from_loop())
