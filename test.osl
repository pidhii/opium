require "base"
require "number"
require "string"
require "console"
require "array"


addLists(xs, ys) =
  match xs, ys in
  | x : xs, y : ys -> (x + y) : addLists(xs, ys)
  | otherwize -> []


foldLeft(xs, f, z) =
  match xs in
  | x : xs ->
      let z = f(z, x)
      in foldLeft(xs, f, z)
  | otherwize -> z


println(0 + 1)
println(1 + 2)
println("one" + "two")

println(foldLeft(list(1, 2, 3, 4, 5), sum, 0))
println(list("a", "b", "c", "d", "e").foldLeft(+, ""))

println(addLists(list(1, 2, 3), list(1, 2, 3)))

println(add3(1, 2, 3))
  where add3(x, y, z) = x + y + z

join(strs, sep) =
  match strs in
  | first : rest ->
        foldLeft(rest, join2, first)
        where join2(s1, s2) = appendStrings(s1, sep, s2)
  | otherwize -> ""


println(list("one", "two", "three").join(", "))



// FIXME: atm you have to put parenthes even with zero type parameters
type result(T, U) = Ok(T) | Error(U)


something_very_complicated_and_error_prone() = {
  println("Oh no, something went wrong")
  Error("fuck")
}

match something_very_complicated_and_error_prone() in
| Ok(res) -> println("success:", res)
| Error(err) -> println("error:", err)
  


// FIXME: atm it is possible to put TypeSig in a list of template parameters
type triplet(T, U, V) = {
  first T,
  second U,
  third result(T, U)
}

t = triplet(1, "two", Ok(2))
println("triplet:", t)
println("first + 1:", t#first + 1)
println("third:", t#third)
set t#third = Error("no no no")
println("third:", t#third)




arr1 + arr2 = appendArrays(arr1, arr2)
arr[k] = arrayRef(arr, k)
set arr[k] = x = arraySet(arr, k, x)

arr = array(1, 2, 3)
println("arr:", arr)
println("arr[1]:", arr[1])
set arr[1] = 5
println("arr[1]:", arr[1])

println("merged array:", arr + array(1, 2, 3))


type vector(T) = {
  data array(T),
  size num
}


vector() =
  vector(makeUninitializedArray(0), 0)

push(vec, x) = {
  // Check if we have enough space for the new element and reallocate array with
  // doubled capacity if current space is not sufficient
  capacity = length(vec#data)
  if vec#size == capacity then
  {
    newcapacity = if capacity == 0 then 1 else capacity*2
    set vec#data = copyArray(vec#data, 0, newcapacity)
  }
  
  // Append new element and increment vector size
  set vec#data[vec#size] = x
  set vec#size = vec#size + 1
}

require "error"

vec[k] =
  if k >= vec#size then
    error("vector index out of range:", k, vec)
  else
    vec#data[k]

set vec[k] = x =
  if k >= vec#size then
    error("vector index out of range:", k, vec)
  else
    set vec#data[k] = x


vec = vector()
vec.push(1)
vec.push(2)
vec.push(3)
println("vector data:", vec#data)
println("vec[2]:", vec[2])
println("vec[3]:", vec[3])
