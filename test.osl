;;;;
;;
;; Define cons-list:
;;
;;   type cons_list(T) = Cons(T, cons_list(T))
;;                     | EmptyList
;;
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Constructor types
  (predicate (result-of (oslctor:Cons T (cons-list T)) (cons-list T)))
  (predicate (result-of (oslctor:EmptyList) (cons-list _)))

  ;; Rules for type-cases
  (predicate (match-on (oslctor:Cons T (cons-list T)) (cons-list T)))
  (predicate (match-on (oslctor:EmptyList) (cons-list _)))

  ;; Builtin Scheme functions for cons-lists
  (predicate (result-of (list . Ts) (cons-list T)) (all T Ts))
  (predicate (result-of (car (cons-list T)) T))
  (predicate (result-of (cdr (cons-list T)) (cons-list T)))

}
;;
#pragma scheme-translator {
  ;; Rules for translation of cases expressions with cons-list
  (cases-rule (oslctor:Cons _ _) (cons-list _) pair? unpack-pair)
  (cases-rule (oslctor:EmptyList) (cons-list _) null? <unused>) ;; nothing to unpack

  ;; Inline auxiliary functions to avoid type-check and name mangling
  (inline
    (define (unpack-pair p) (values (car p) (cdr p)))
    (define oslctor:Cons cons)
    (define (oslctor:EmptyList) '()))
}


;;;;
;;
;; Redefine operator +
;;
#pragma scheme-translator {
  ;; Rename Scheme builtin `+` and `string-append`
  (inline
    (define sum +)
    (define addStrs string-append))
}
;;
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Type signatures for the renamed functions
  (predicate (result-of (addStrs . Strs) str) (all str Strs))
  (predicate (result-of (sum . Nums) num) (all num Nums))
}
;; Overload new `+` to work for both numbers and strings
n1 + n2 = sum(n1, n2)
s1 + s2 = addStrs(s1, s2)


addLists(xs, ys) =
  match xs, ys in
  | x : xs, y : ys -> (x + y) : addLists(xs, ys)
  | otherwize -> []


foldLeft(xs, f, z) =
  match xs in
  | x : xs ->
      let z = f(z, x)
      in foldLeft(xs, f, z)
  | otherwize -> z



;;;;
;;
;; Console output functions
;;
#pragma prolog {
  (predicate (result-of (display _) void))
  (predicate (result-of (newline) void))
  (predicate (result-of (println . _) void))
}
#pragma scheme-translator {
  (inline
    (define (println x . rest)
      (display x)
      (if (null? rest)
          (newline)
          (begin
            (display " ")
            (apply println rest)))))
}


println(0 + 1)
println(1 + 2)
println("one" + "two")

println(foldLeft(list(1, 2, 3, 4, 5), sum, 0))
println(list("a", "b", "c", "d", "e").foldLeft(+, ""))

println(addLists(list(1, 2, 3), list(1, 2, 3)))

println(add3(1, 2, 3))
  where add3(x, y, z) = x + y + z

join(strs, sep) =
  match strs in
  | first : rest ->
        foldLeft(rest, join2, first)
        where join2(s1, s2) = addStrs(s1, sep, s2)
  | otherwize -> ""

println(list("one", "two", "three").join(", "))



type result(T, U) = Ok(T) | Error(U)


something_very_complicated_and_error_prone() = {
  println("Oh no, something went wrong")
  Error("fuck")
}

match something_very_complicated_and_error_prone() in
| Ok(res) -> println("success:", res)
| Error(err) -> println("error:", err)
  
