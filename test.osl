
println(list([1,2,3,4].iter()))

println("iterate over list")
for x in [1, 2, 3, 4, 5] do
  println("-", x)

println("iterate over vector")
vec = vector([1, 2, 3, 4].iter())
vec.push(5)
for x in vec do
  println("vec -", x)


require "subprocess"
for line in run("ls -lrth")#stdout.lines() do
  println(line)


require "dict"
dd = dict()
set dd["one"] = 1
println(dd["one"])
set dd["two"] = 2
for key, val in dd do
  println("dd[", key, "] = ", val)


require "trie"
d = trie()
set d = d.insert("one", 1)
println(d["one"])


require "json"
let j = open("test.json", "r").read_json() in
println(dict(j))


println("testing regex")
re = regexp("([a-z]+)([0-9]+)")
let s =  "___adfasd12312" in 
if let Some(m) = s.find(re) then {
  for i in 0 : 3 do
    let start, end = unpack(*m.indices(i)) in
    println("  match #", i, " = ", s.view(start, end))
}

// require "zmq"

// type message = {
//   message str,
// }

// message(j json) = message(j["message"].str())
// json(msg message) = {
//   struct = dict()
//   set struct["message"] = JsonString(msg#message)
//   return JsonStructure(struct)
// }

// ctx = zmq_context(1)
// sock = ctx.socket(zmq_rep)
// sock.bind("tcp://*:4444")
// request = sock.receive().expect("Failed to receive a request").str().parse_json()
// println("request.message:", message(request)#message)
// response = call_with_output_string(port => writejson(message("Hi there!").json(), port))
// println("response:", response)
// sock.send(response)


type foobar = Foo | Bar
foo = Foo
match foo in
| Foo -> println("This is foo")
| Bar -> println("This is bar")


println("c,compile".split(","))


if let hd : tl = [1, 2, 3] then
  println("head: ", hd, ", tail: ", tl)


blb = blob(64)
println("blb: ", blb)
set blb#u16[0] = 0xBEAF
println("blb: ", blb)


case 1 + 2 in 
| 1 -> println("one")
| 2 -> println("two")
| 3 -> println("three")
| 4 -> println("four")
| otherwize -> println("idk")


println("test division: ", 4 / 2 / 2)

let x = 1 in
println("test unary: ", -x < 0)

type one = One
{
  tup = pack(1, "one", One)
  println("tup: ", tup)
  let t1, t2, t3 = unpack(tup) in
  println(t1, " ", t2, " ", t3)
}


test_null(x str?) =
  println("test_null: bool(", x, ") = ", bool(x))
test_null("not-null")
test_null(null)

println(format("~S", "ĸ•⌚⏪"))

{ if true then "something" } :: str?
