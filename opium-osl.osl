require "osl-config" // generated during build; contains `default_oslpath`


type mode = Run | Compile(str) | RunCompiled

////////////////////////////////////////////////////////////////////////////////
//                   Process command-line arguments
//
// Default options
mode = RunCompiled // Default mode
optimize = false   // Default optimization settings (dont optimize compilation target)
verbose = false    // Default verbosity (silent)
gdb = false
tracelen = 20
compile_target = ""

// Parse command-line
args = getopt(argv, options)
where options = [
  // --help,-h
  option("help")
    .short("h")
    .docstring("print help and exit")
    .handle(_ => {
      println("usage: opium-osl [OPTIONS] <INPUT-FILE>")
      println("")
      println("OPTIONS:")
      println(help(options))
      exit(0)
    })
  ,
  // --verbose,-v
  option("verbose")
    .short("v")
    .docstring("enable verbose output")
    .handle(_ => set verbose = true)
  ,
  // --run,-r
  option("run")
    .short("r")
    .docstring("run the script without compilation (can't use foreign code)")
    .handle(_ => set mode = Run)
  ,
  // --compile,-c <output-filename>
  option("compile")
    .short("c")
    .docstring("compile the script into executable file")
    .value("OUTPUT-FILE")
    .handle(output_filename => set mode = Compile(output_filename))
  ,
  // --run-compiled
  option("run-compiled")
    .docstring("compile the script into an executable and run it (default)")
    .handle(_ => set mode = RunCompiled)
  ,
  // --optimize,-O
  option("optimize")
    .short("O")
    .docstring("enable optimizations during compilation")
    .handle(_ => set optimize = true)
  ,
  // --gdb
  option("gdb")
    .docstring("run osl with GDB")
    .handle(_ => set gdb = true)
  ,
  option("trace-length")
    .docstring("typecheck track length (see `osl --help`)")
    .value("TRACE-LENGTH")
    .handle(x => set tracelen = num(x))
  ,
  option("cpp")
    .docstring("compile via a C++ source file")
    .handle(_ => set compile_target = "-c++")
  ,
  option("objc")
    .docstring("compile via an Objective C source file")
    .handle(_ => set compile_target = "-objc")
]

// Expecting at least a single position argument which is the input filename
if length(args) < 1 then
  error("input file not specified")
input = args[0]


////////////////////////////////////////////////////////////////////////////////
//                             Helper functions
//
info(message) =
{
  if verbose then
    println("opium-osl ", message)
}

// Translate OSL into Scheme
translate_opium_script(osl_filename, scm_filename) =
{
  // Resolve path for OSL modules
  info("translating OSL into Scheme")
  command = format("./install/bin/osl -o ~A --oslpath ~A --trace-length ~A ~A",
                   scm_filename, default_oslpath, tracelen, osl_filename)
  if verbose then
   info("osl command: " + command)

  if gdb then
  {
    system("gdb --args " + command)
    return
  }

  p = run(command)
  pid, exited, status = p.wait()
  if status != 0 then
  {
    p#stderr.lines().foreach(println)
    eprintln("OSL translation failed")
    exit(1)
  }
  else if verbose then
    p#stderr.lines().foreach(println)
}

// Run Scheme with Chicken Scheme interpreter
run_scheme(scm_filename) =
{
  info("evaluating Scheme script with Chicken interpreter")
  cmdline_args_string = cdr(args).iter().join(" ")
  command = "chicken-csi -s " + scm_filename + " " + cmdline_args_string
  if verbose then
   info("csi command: " + command)
  return system(command)
}

// Compile Scheme with Chicken Scheme compiler
compile_scheme(scm_filename, output_filename) =
{
  info("compiling Scheme script with Chicken compiler")
  compile_flags = "-strict-types -o " + output_filename + " " + compile_target
  if optimize then
    set compile_flags = compile_flags + " -O5 -local -no-bound-checks -no-procedure-checks -no-argc-checks"
  command = "chicken-csc " + compile_flags + " " + scm_filename
  if verbose then
   info("csc command: " + command)
  return system(command)
}


////////////////////////////////////////////////////////////////////////////////
//                                Main
//
scm_filename = run("mktemp")#stdout.read().unpack().chomp() // temporary file to store Scheme script
translate_opium_script(input, scm_filename)
match mode in
| Run -> run_scheme(scm_filename)
| Compile(output_filename) -> compile_scheme(scm_filename, output_filename)
| RunCompiled -> {
  exec_filename = run("mktemp")#stdout.read().unpack().chomp() // temporary file for executable
  compile_scheme(scm_filename, exec_filename)
  system(exec_filename)
}
