require "osl-config" // generated during build; contains `default_oslpath`
require "getopt"


type mode = Run | Compile(str) | RunCompiled

////////////////////////////////////////////////////////////////////////////////
//                   Process command-line arguments
//
// Default options
mode = RunCompiled // Default mode
optimize = false   // Default optimization settings (dont optimize compilation target)
verbose = false    // Default verbosity (silent)
gdb = false
tracelen = 20
compile_target = ""
inputpath = ""
runargs = vector()


print_help() =
{
  println("usage: ", argv[0], " [OPTIONS] ", "<input-file>")
  println("")
  println("OPTIONS:")
  println(" -h      print help and exit")
  println(" -v      enable verbose output")
  println(" -r      run the script without compilation (note: can't use foreign code)")
  println(" -c <output-file>")
  println("         compile the script into an executable")
  println(" -R      compile the script into an executable and run it (default)")
  println(" -t <trace-length>")
  println("         typecheck trace length (see `osl --help`)")
  println(" --c++   compile via a C++ source file")
  println(" --objc  compile via an Objective C source file")
}

for opt, arg in getopt(argv, "hvrc:Rt:-:") do
{
  if opt == 0 then
  {
    if inputpath == "" then
      set inputpath = *arg
    else
      runargs.push(*arg)

    continue
  }

  case str([char(opt)]) in
  | "h" -> { print_help() exit(0) }
  | "v" -> set verbose = true
  | "r" -> set mode = Run
  | "c" -> set mode = Compile(*arg)
  | "R" -> set mode = RunCompiled
  | "t" -> set tracelen = num(*arg)
  | "-" -> set compile_target = "-" + *arg
  | otherwize -> error("Invalid command-line option", char(opt), arg)
}


////////////////////////////////////////////////////////////////////////////////
//                             Helper functions
//
info(message) =
{
  if verbose then
    eprintln("opium-osl ", message)
}


// Translate OSL into Scheme
translate_opium_script(osl_filename, scm_filename) =
{
  // Resolve path for OSL modules
  info("translating OSL into Scheme")
  command = format("./install/bin/osl -o ~A --oslpath ~A --trace-length ~A ~A",
                   scm_filename, default_oslpath, tracelen, osl_filename)
  if verbose then
   info("osl command: " + command)

  p = run(command)

  stdoutbuf = openstring()
  while let Some(line) = p#stderr.readline() do
    stdoutbuf.writeln(line)

  _, _, status = p.wait()
  if status != 0 then
  {
    println("OSL translation failed")
    print(str(stdoutbuf))
    exit(1)
  }
  else if verbose then
    print(str(stdoutbuf))
}

// Run Scheme with Chicken Scheme interpreter
run_scheme(scm_filename) =
{
  info("evaluating Scheme script with Chicken interpreter")
  cmdline_args_string = runargs.iter().join(" ", "")
  command = "chicken-csi -s " + scm_filename + " " + cmdline_args_string
  if verbose then
   info("csi command: " + command)
  return system(command)
}

// Compile Scheme with Chicken Scheme compiler
compile_scheme(scm_filename, output_filename) =
{
  info("compiling Scheme script with Chicken compiler")
  compile_flags = "-strict-types -o " + output_filename + " " + compile_target
  if optimize then
    set compile_flags = compile_flags + " -O5 -local -no-bound-checks -no-procedure-checks -no-argc-checks -d0"
  command = "chicken-csc " + compile_flags + " " + scm_filename
  if verbose then
   info("csc command: " + command)
  return system(command)
}


////////////////////////////////////////////////////////////////////////////////
//                                Main
//
scm_filename = run("mktemp")#stdout.read().unpack().chomp() // temporary file to store Scheme script
translate_opium_script(inputpath, scm_filename)
match mode in
| Run -> run_scheme(scm_filename)
| Compile(output_filename) -> compile_scheme(scm_filename, output_filename)
| RunCompiled -> {
  exec_filename = run("mktemp")#stdout.read().unpack().chomp() // temporary file for executable
  compile_scheme(scm_filename, exec_filename)
  system(exec_filename + " " + runargs.iter().join(" ", ""))
}
