%require "3.2"
%language "C"

%define parse.error verbose
/* Just for the sake of safety. */
/* %define parse.lac full */
/* LAR(1) has issues after adding module-syntax. */
%define lr.type ielr
/*%glr-parser*/
%define parse.lac full
%define api.value.type { opi::value }

%define api.pure full
%param { yyscan_t scanner }
%locations

%{
#include "opium/value.hpp"
#include "opium/logging.hpp"
#include "opium/pretty_print.hpp"
#include "opium/stl/vector.hpp"
#include "opium/lisp_parser.hpp"
#include "opium/utilities/ranges.hpp"
#include "opium/utilities/state_saver.hpp"

#include <unordered_set>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <filesystem>
#include <cassert>

#include "location.hh"


static opi::value* g_result_ptr;

#define YYMALLOC opi::allocate
#define YYREALLOC GC_realloc
#define YYFREE GC_free
#define YYSTACK_USE_ALLOCA 1


namespace opi::osl {

opi::value
parse(std::FILE *file, bool reset_includes = false);

}

size_t g_fileoffs_left;
size_t g_fileoffs_right;

static opi::value
mangle_type_constructor(opi::value ctor)
{
  return opi::sym("oslctor:" + std::string(opi::sym_name(ctor)));
}


static opi::value
random_access_getter()
{
  return "osl:ref";
}


static opi::value
random_access_setter()
{
  return "osl:set";
}



template <std::output_iterator<opi::value> Output>
opi::value
generate_record_definition(opi::value typesign, opi::value name, opi::value ctorname,
                           opi::value fields, opi::value fieldtypes,
                           opi::value predname, Output output)
{
  // Getters and setters
  opi::value accessors = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value gettername = opi::sym(std::format("{}-{}", ctorname, field));
    const opi::value settername = opi::sym(std::format("{}-set-{}!", ctorname, field));
    accessors = append(accessors, list(list(field, gettername, settername)));
  }

  // Write define-record-type expression
  const opi::value recorddef = list("define-record-type", name,
                                    cons(ctorname, fields), predname,
                                    opi::dot, accessors);
  *output++ = list("pragma", "scheme-translator", list("inline", recorddef));

  opi::value predicates = opi::nil;

  // Write type signature for constructor
  const opi::value ctorsign = cons(ctorname, fieldtypes);
  const opi::value ctorpred = list("predicate", list("result-of", ctorsign, typesign));
  predicates = append(predicates, list(ctorpred));

  // Write type signatures of acessors
  if (fields != opi::nil)
  {
    for (const auto &[field, type] : opi::utl::zip(range(accessors), range(fieldtypes)))
    {
      const opi::value getter = car(cdr(field));
      const opi::value setter = car(cdr(cdr(field)));
      const opi::value getterpred =
          list("predicate", list("result-of", list(getter, typesign), type));
      const opi::value setterpred = 
          list("predicate", list("result-of", list(setter, typesign, type), "void"));
      predicates = append(predicates, list(getterpred, setterpred));
    }
  }

  *output++ = list("pragma", "prolog", opi::dot, predicates);

  return recorddef;
}


static std::pair<opi::value, opi::value>
field_accessors(opi::value recorddef, opi::value field)
{
  const opi::value accessors = cdr(cdr(cdr(cdr(recorddef))));
  opi::value fieldaccessors;
  if (not assoc(field, accessors, fieldaccessors))
    throw std::runtime_error {std::format("No accessors for field {}", field)};
  return {car(fieldaccessors), car(cdr(fieldaccessors))};
}


static opi::value
generate_unpack_definition(opi::value recorddef, opi::value unpackname)
{
  const opi::value signature = car(cdr(cdr(recorddef)));
  const opi::value fields = cdr(signature);

  opi::value args = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value getter = field_accessors(recorddef, field).first;
    const opi::value getfield = list(getter, "x");
    args = append(args, list(getfield));
  }

  return list("define", list(unpackname, "x"), cons("values", args));
}


template <std::output_iterator<opi::value> Output>
void
generate_overloaded_getter(opi::value recorddef, opi::value field,
                           opi::value name, Output output)
{
  const opi::value getter = field_accessors(recorddef, field).first;
  *output++ = list("define-overload", list(name, "x"), list(getter, "x"));
}


template <std::output_iterator<opi::value> Output>
static void
generate_variant(opi::value typesign, opi::value ctorsign, Output output)
{
  // NOTE: Don't allow overloading constructors for now
  //       (no particular reason, just a design decision; can change it later)
  const opi::value type = car(typesign);
  const opi::value ctorname = car(ctorsign);
  const opi::value mangledctor = mangle_type_constructor(ctorname);
  const opi::value mangledctorsign = cons(mangledctor, cdr(ctorsign));
  const size_t arity = length(cdr(ctorsign));

  const opi::value recordname = opi::sym(std::format("{}.{}", type, ctorname));
  opi::value fields = opi::nil;
  for (size_t i = 0; i < arity; ++i)
  {
    const std::string fieldname = std::format(":{}", i);
    fields = append(fields, list(opi::sym(fieldname)));
  }
  const opi::value predname = opi::sym(std::format("{}?", recordname));
  const opi::value unpackname = opi::sym(std::format("unpack-{}", recordname));

  // Generate Scheme inlines and cases-rule
  const opi::value recorddef = generate_record_definition(typesign, recordname,
                                                          mangledctor, fields,
                                                          cdr(ctorsign),
                                                          predname, output);
  const opi::value unpackdef = generate_unpack_definition(recorddef, unpackname);

  *output++ = list("pragma", "scheme-translator",
                    list("inline", unpackdef),
                    list("cases-rule", mangledctorsign, typesign, predname, unpackname));

  // Generate Prolog predicates
  const opi::value matchpred =
      list("predicate", list("match-on", mangledctorsign, typesign));

  *output++ = list("pragma", "prolog", matchpred);
}


template <std::output_iterator<opi::value> Output>
static void
generate_variant_type(opi::value typesign, opi::value variants, Output output)
{
  for (const opi::value ctorsign : range(variants))
    generate_variant(typesign, ctorsign, output);
}


static opi::value
overloaded_getter_name(opi::value fieldname)
{
  return opi::sym(std::format("osl:#{}", fieldname));
}

static opi::value
overloaded_setter_name(opi::value fieldname)
{
  return opi::sym(std::format("osl:#set-{}!", fieldname));
}

template <std::output_iterator<opi::value> Output>
static void
generate_record_type(opi::value typesign, opi::value fields, Output output)
{
  const opi::value recordname = car(typesign);
  // const opi::value ctorname = recordname;

  opi::value fieldnames = opi::nil;
  opi::value fieldtypes = opi::nil;
  for (const opi::value field : range(fields))
  {
    fieldnames = append(fieldnames, list(car(field)));
    fieldtypes = append(fieldtypes, list(car(cdr(field))));
  }

  const opi::value mangledname = opi::sym(std::format("osl:{}", recordname));
  const opi::value predname = opi::sym(std::format("{}?", mangledname));
  const opi::value recorddef =
      generate_record_definition(typesign, opi::sym(std::format("<{}>", mangledname)),
                                 mangledname, fieldnames, fieldtypes, predname,
                                 output);
  *output++ = list("define-overload", cons(recordname, fieldnames),
                   cons(mangledname, fieldnames));

  for (const opi::value fieldname : range(fieldnames))
  {
    const auto [getter, setter] = field_accessors(recorddef, fieldname);
    const opi::value ovgetter = overloaded_getter_name(fieldname);
    const opi::value ovsetter = overloaded_setter_name(fieldname);
    *output++ = list("define-overload", list(ovgetter, "x"), list(getter, "x"));
    *output++ = list("define-overload", list(ovsetter, "x", "v"), list(setter, "x", "v"));
  }
}


static std::unordered_set<std::filesystem::path> g_included_files;

opi::value
load_file(const std::filesystem::path &path)
{
  const std::filesystem::path dirpath = path.parent_path();

  if (FILE *file = fopen(path.c_str(), "r"))
  {
    const std::filesystem::path curpath = std::filesystem::current_path();
    std::filesystem::current_path(dirpath);
    const opi::value result = opi::osl::parse(file, false);
    std::filesystem::current_path(curpath);

    fclose(file);

    return result;
  }
  else
    throw std::runtime_error {std::format("Failed to open file {} for reading", path.c_str())};
}



%}

%code requires {
  #include "opium/value.hpp"

  using namespace opi;

  typedef void* yyscan_t;
}

%code {
  extern "C" int
  yylex(YYSTYPE *yylval_p, YYLTYPE *loc_p, yyscan_t yyscanner);

  void
  yyerror(YYLTYPE *loc_p, yyscan_t scnner, const char *what)
  {
    opi::source_location location;
    location.source = "test.opi";
    location.start = g_fileoffs_left;
    location.end = g_fileoffs_right;
    opi::error("parse error: {}\n{}", what, opi::display_location(location));
  }


}


// =============================================================================
//                                Tokens
%token REQUIRE
%token IDENT
%token CAPIDENT
%right MATCH IN RIGHT_ARROW OTHERWIZE
%token BEGIN_STRING STRING_CHUNK END_STRING
%token INTEGER FLOAT BOOLEAN
%token PRAGMA_
%token TYPE
%token SET
%token OF

%right '|'

%nonassoc IF THEN
%right ELSE

%left '='

%right LET LETREC WHERE

%right FAT_RIGHT_ARROW
%nonassoc EQ NE
%nonassoc LT LE GT GE
%left '+' '-' '%'
%left '*' '/'
%left '.' ':' '#'

// =============================================================================
//                              Structures
%type ApplExpr Expr
%type ListOfExprs
%type SeqOfExprs
%type TopLvlExpr
%type Match MatchClause MatchClauses
%type AtomPattern ExprPattern ListOfExprPatterns
%type String StringChunks
%type Bind ListOfBinds
%type Ctor
%type TopLvlSeq TopLvlExpr
%type TypeDef TypeSign CtorSign ListOfCtorSigns TypeParam ListOfTypeParams ListOfFields
%type If
%type Lambda
%type ExprWithOptTypeParam

%nonassoc AFTER_APPLY
%left APPLY
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
%start Entry


%%

Entry
  : TopLvlSeq { *g_result_ptr = $1; }
;

String
  : BEGIN_STRING StringChunks END_STRING {
    std::string result;
    for (const value chunk : range($2))
      std::ranges::copy(str_view(chunk), std::back_inserter(result));
    $$ = str(result);
  }
;

StringChunks
  : { $$ = nil; }
  | STRING_CHUNK StringChunks { $$ = cons($1, $2); }
;

ApplExpr
  : IDENT
  | INTEGER
  | FLOAT
  | BOOLEAN
  | String
  | '{' SeqOfExprs '}' { $$ = cons("begin", $2); }
  | '[' ']' { $$ = list(mangle_type_constructor("EmptyList")); }
  | '+' { $$ = "+"; }
  | '-' { $$ = "-"; }
  | '*' { $$ = "*"; }
  | '/' { $$ = "/"; }
  | EQ { $$ = "=="; }
  | NE { $$ = "!="; }
  | GT { $$ = ">"; }
  | LT { $$ = "<"; }
  | GE { $$ = ">="; }
  | LE { $$ = "<="; }
  | ApplExpr '(' ListOfExprs ')' %prec APPLY { $$ = cons($1, $3); }
  | '(' Expr ')' %prec AFTER_APPLY { $$ = $2; }
  | ApplExpr '.' IDENT '(' ListOfExprs ')' { $$ = list($3, $1, dot, $5); }
  | ApplExpr '#' IDENT { $$ = list(overloaded_getter_name($3), $1); }
  | ApplExpr '[' Expr ']' { $$ = list(random_access_getter(), $1, $3); }
;

Expr
  : ApplExpr
  | Ctor '(' ListOfExprs ')' %prec APPLY { $$ = cons($1, $3); }
  | SET IDENT '=' Expr { $$ = list("set!", $2, $4); }
  | SET ApplExpr '[' Expr ']' '=' Expr { $$ = list(random_access_setter(), $2, $4, $7); }
  | SET ApplExpr '#' IDENT '=' Expr { $$ = list(overloaded_setter_name($4), $2, $6); }
  | Expr '=' Expr { $$ = list(issym($1) ? "define" : "define-overload", $1, $3); }
  | Expr ':' Expr { $$ = list(mangle_type_constructor("Cons"), $1, $3); }
  | Expr '+' Expr { $$ = list("+", $1, $3); }
  | Expr '-' Expr { $$ = list("-", $1, $3); }
  | Expr '*' Expr { $$ = list("*", $1, $3); }
  | Expr '/' Expr { $$ = list("/", $1, $3); }
  | Expr EQ Expr { $$ = list("==", $1, $3); }
  | Expr NE Expr { $$ = list("!=", $1, $3); }
  | Expr GT Expr { $$ = list(">", $1, $3); }
  | Expr LT Expr { $$ = list("<", $1, $3); }
  | Expr GE Expr { $$ = list(">=", $1, $3); }
  | Expr LE Expr { $$ = list("<=", $1, $3); }
  | Lambda
  | If
  | Match
  | LET ListOfBinds IN Expr { $$ = list("let", $2, $4); }
  | LETREC ListOfBinds IN Expr { $$ = list("letrec", $2, $4); }
  | Expr WHERE ListOfBinds { $$ = list("letrec", $3, $1); }
  | PRAGMA_ IDENT STRING_CHUNK {
    lisp_parser parser;
    assert(isstr($3));
    std::istringstream buf {std::string(str_view($3))};
    $$ = list("pragma", $2, dot, parser.parse_all(buf));
  }
;

Lambda
  : '(' ListOfExprs ')' FAT_RIGHT_ARROW Expr { $$ = list("lambda", $2, $5); }
  | IDENT FAT_RIGHT_ARROW Expr { $$ = list("lambda", list($1), $3); }
;

If
  : IF Expr THEN Expr ELSE Expr { $$ = list("if", $2, $4, $6); }
  | IF Expr THEN Expr { $$ = list("if", $2, $4); }
;

Match
  : MATCH ListOfExprs IN MatchClauses {
    // Fix otherwize-clause
    value newclauses = nil;
    const size_t ncols = length($2);
    for (const value clause : range($4))
    {
      if (car(car(clause)) == "otherwize")
      {
        const auto makewild = []() { return sym("_"); };
        opi::stl::vector<value> newpat;
        std::ranges::generate_n(std::back_inserter(newpat), ncols, makewild);
        const value newclause = cons(list(newpat), cdr(clause));
        newclauses = append(newclauses, list(newclause));
      }
      else
        newclauses = append(newclauses, list(clause));
    }
    $$ = list("cases", $2, dot, newclauses);
  }
;

SeqOfExprs
  : { $$ = nil; }
  | Expr SeqOfExprs %prec AFTER_APPLY { $$ = cons($1, $2); }
;

TopLvlSeq
  : { $$ = nil; }
  | TopLvlExpr TopLvlSeq %prec AFTER_APPLY { $$ = append($1, $2); }
;

TopLvlExpr
  : Expr { $$ = list($1); }
  | TypeDef
  | REQUIRE String {
    std::filesystem::path fullpath = std::filesystem::absolute(str_view($2));
    if (fullpath.extension() == "")
      fullpath += ".osl";
    if (g_included_files.contains(fullpath))
      $$ = nil;
    else
    {
      g_included_files.emplace(fullpath);
      $$ = load_file(fullpath);
    }
  }
;

TypeDef
  : TYPE TypeSign '=' ListOfCtorSigns {
    opi::stl::vector<value> tape;
    generate_variant_type($2, $4, std::back_inserter(tape));
    $$ = list(tape);
  }
  | TYPE TypeSign '=' '{' ListOfFields '}' {
    opi::stl::vector<value> tape;
    generate_record_type($2, $5, std::back_inserter(tape));
    $$ = list(tape);
  }
;

TypeSign
  : IDENT %prec AFTER_APPLY
  | IDENT '(' ListOfTypeParams ')' %prec APPLY { $$ = cons($1, $3); }
;

ListOfCtorSigns
  : CtorSign { $$ = list($1); }
  | CtorSign '|' ListOfCtorSigns { $$ = cons($1, $3); }
;

CtorSign: CAPIDENT '(' ListOfTypeParams ')' { $$ = cons($1, $3); };

ListOfTypeParams
  : { $$ = nil; }
  | TypeParam { $$ = list($1); }
  | TypeParam ',' ListOfTypeParams { $$ = cons($1, $3); }
;

TypeParam: CAPIDENT | TypeSign;

ListOfFields
  : { $$ = nil; }
  | IDENT TypeParam { $$ = list(list($1, $2)); }
  | IDENT TypeParam ',' ListOfFields { $$ = cons(list($1, $2), $4); }
;

/*ListOfExprs*/
  /*: { $$ = nil; }*/
  /*| Expr { $$ = list($1); }*/
  /*| Expr ',' ListOfExprs { $$ = cons($1, $3); }*/
/*;*/

ListOfExprs
  : { $$ = nil; }
  | ExprWithOptTypeParam { $$ = list($1); }
  | ExprWithOptTypeParam ',' ListOfExprs { $$ = cons($1, $3); }
;

ExprWithOptTypeParam
  : Expr
  | Expr TypeParam { $$ = list($1, $2); }
;


MatchClauses
  :  MatchClause { $$ = list($1); }
  |  MatchClause MatchClauses { $$ = cons($1, $2); }
;

MatchClause
  : '|' ListOfExprPatterns RIGHT_ARROW Expr { $$ = cons($2, list($4)); }
;

ListOfExprPatterns
  : { $$ = nil; }
  | ExprPattern { $$ = list($1); }
  | ExprPattern ',' ListOfExprPatterns { $$ = cons($1, $3); }
;

ExprPattern
  : AtomPattern
  | ExprPattern ':' ExprPattern { $$ = list(mangle_type_constructor("Cons"), $1, $3); }
;

AtomPattern
  : IDENT
  | '(' ExprPattern ')' { $$ = $2; }
  | Ctor '(' ListOfExprPatterns ')' { $$ = cons($1, $3); }
  | OTHERWIZE { $$ = "otherwize"; }
;


ListOfBinds
  : Bind { $$ = list($1); }
  | Bind ',' ListOfBinds { $$ = cons($1, $3); }
;

Bind
  : IDENT '=' Expr { $$ = list($1, $3); }
  | IDENT '(' ListOfExprs ')' '=' Expr {
    const value lambda = list("lambda", $3, $6);
    $$ = list($1, lambda);
  }
;

Ctor
  : CAPIDENT { $$ = mangle_type_constructor($1); }
;

%%

typedef void* yyscan_t;

extern int
yylex_init(yyscan_t *scanner);

extern void
yyset_in(FILE *in, yyscan_t scanner);

extern void
yylex_destroy(yyscan_t scanner);


namespace opi::osl {

opi::value
parse(std::FILE *file, bool reset_includes)
{
  opi::utl::state_saver _ {g_fileoffs_left, g_fileoffs_right};
  g_fileoffs_left = 0;
  g_fileoffs_right = 0;

  opi::value result;

  opi::value *result_ptr_save = &result;
  std::swap(result_ptr_save, g_result_ptr);

  if (reset_includes)
    g_included_files.clear();

  yyscan_t scanner;
  yylex_init(&scanner);
  yyset_in(file, scanner);
  yyparse(scanner);
  yylex_destroy(scanner);

  std::swap(result_ptr_save, g_result_ptr);

  return result;
}

} // namespace opi::osl
