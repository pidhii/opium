%require "3.2"
%language "C"

%define parse.error verbose
%define lr.type ielr
%define parse.lac full
%define api.value.type { opi::value }

%define api.pure full
%define api.push-pull push
%param { yyscan_t scanner }
%locations
%define api.location.type { range_location }

%{
#include "parse.hpp"
#include "syntax_definitions.h"
/*#include "location.hh"*/
#include "unroll_flow.hpp" // FIXME
#include "macros.hpp" // FIXME

#include "opium/value.hpp"
#include "opium/logging.hpp"
#include "opium/pretty_print.hpp"
#include "opium/stl/vector.hpp"
#include "opium/lisp_parser.hpp"
#include "opium/utilities/ranges.hpp"
#include "opium/utilities/state_saver.hpp"
#include "opium/utilities/path_resolver.hpp"
#include "opium/stl/unordered_map.hpp"
#include "opium/hash.hpp"

#include <unordered_set>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <filesystem>
#include <cassert>


static opi::value* g_result_ptr;

#define YYMALLOC opi::allocate
#define YYREALLOC GC_realloc
#define YYFREE GC_free
#define YYSTACK_USE_ALLOCA 1

#define YYLLOC_DEFAULT(Cur, Rhs, N)                    \
do {                                                   \
  if (N)                                               \
  {                                                    \
    (Cur).left = YYRHSLOC(Rhs, 1).left;                \
    (Cur).right = YYRHSLOC(Rhs, N).right;              \
  }                                                    \
  else                                                 \
  {                                                    \
    (Cur).left = (Cur).right = YYRHSLOC(Rhs, 0).right; \
  }                                                    \
} while (0)


struct range_location;

namespace opi::osl {

std::vector<std::string> pathes = {""};

opi::source_location
make_location(const range_location &loc);

static
std::optional<int> start_token;

static
std::optional<YYLTYPE> start_location;

}

static
opi::osl::generic_lexer *g_current_lexer;

static
opi::osl::tree_parser *g_current_tree_parser;


static std::string g_source;

static void
bindloc(opi::value val, const range_location &loc);

static opi::value
mangle_type_constructor(opi::value ctor)
{
  const opi::value result = opi::sym("oslctor:" + std::string(opi::sym_name(ctor)));
  copy_location(ctor, result);
  return result;
}


static opi::value
random_access_getter()
{ return "osl:ref"; }


static opi::value
random_access_setter()
{ return "osl:set"; }



template <std::output_iterator<opi::value> Output>
opi::value
generate_record_definition(opi::value typesign, opi::value name, opi::value ctorname,
                           opi::value fields, opi::value fieldtypes,
                           opi::value predname, Output output)
{
  // Getters and setters
  opi::value accessors = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value gettername = opi::sym(std::format("{}-{}", ctorname, field));
    const opi::value settername = opi::sym(std::format("{}-set-{}!", ctorname, field));
    copy_location(field, gettername);
    copy_location(field, settername);
    accessors = append(accessors, list(list(field, gettername, settername)));
  }

  // Write define-record-type expression
  const opi::value fixname = opi::sym(std::format("%{}", name));
  const opi::value recorddef = list("define-record-type", fixname,
                                    cons(ctorname, fields), predname,
                                    opi::dot, accessors);
  const opi::value fastrecorddef = list("define-record-type-variant", fixname,
                                        opi::list("unsafe", "unchecked", "inline"),
                                        cons(ctorname, fields), predname,
                                        opi::dot, accessors);
  *output++ = list("pragma", "scheme-translator", list("inline", recorddef, fastrecorddef));

  opi::value predicates = opi::nil;

  // Write type signature for constructor
  const opi::value ctorsign = cons(ctorname, fieldtypes);
  const opi::value ctorpred = list("predicate", list("result-of", ctorsign, typesign));
  predicates = append(predicates, list(ctorpred));

  // Write type signatures of acessors
  if (fields != opi::nil)
  {
    for (const auto &[field, type] : opi::utl::zip(range(accessors), range(fieldtypes)))
    {
      const opi::value getter = car(cdr(field));
      const opi::value setter = car(cdr(cdr(field)));
      const opi::value getterpred =
          list("predicate", list("result-of", list(getter, typesign), type));
      const opi::value setterpred = 
          list("predicate", list("result-of", list(setter, typesign, type), "void"));
      predicates = append(predicates, list(getterpred, setterpred));
    }
  }

  *output++ = list("pragma", "prolog", opi::dot, predicates);

  return recorddef;
}


static std::pair<opi::value, opi::value>
field_accessors(opi::value recorddef, opi::value field)
{
  const opi::value accessors = cdr(cdr(cdr(cdr(recorddef))));
  opi::value fieldaccessors;
  if (not assoc(field, accessors, fieldaccessors))
    throw std::runtime_error {std::format("No accessors for field {}", field)};
  return {car(fieldaccessors), car(cdr(fieldaccessors))};
}


static opi::value
generate_unpack_definition(opi::value recorddef, opi::value unpackname)
{
  const opi::value signature = car(cdr(cdr(recorddef)));
  const opi::value fields = cdr(signature);

  opi::value args = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value getter = field_accessors(recorddef, field).first;
    const opi::value getfield = list(getter, "x");
    args = append(args, list(getfield));
  }

  return list("define", list(unpackname, "x"), cons("values", args));
}



template <std::output_iterator<opi::value> Output>
static void
generate_variant(opi::value typesign, opi::value ctorsign, Output output,
                 const opi::source_location &location)
{
  // NOTE: Don't allow overloading constructors for now
  //       (no particular reason, just a design decision; can change it later)
  const opi::value typenam = issym(typesign) ? typesign : car(typesign);
  const opi::value ctorname = car(ctorsign);
  const opi::value recordname = opi::sym(std::format("{}.{}", typenam, ctorname));
  const opi::value mangledctor = mangle_type_constructor(ctorname);
  const opi::value mangledctorsign = cons(mangledctor, cdr(ctorsign));
  const size_t arity = length(cdr(ctorsign));

  set_location(recordname, location);
  opi::value fields = opi::nil;
  for (size_t i = 0; i < arity; ++i)
  {
    const opi::value fieldname {std::format(":{}", i).c_str()};
    set_location(fieldname, location);
    fields = append(fields, list(fieldname));
  }
  const opi::value predname = opi::sym(std::format("{}?", recordname));
  const opi::value unpackname = opi::sym(std::format("unpack-{}", recordname));
  set_location(predname, location);
  set_location(unpackname, location);

  // Generate record for this variant
  const opi::value recorddef = generate_record_definition(typesign, recordname,
                                                          recordname, fields,
                                                          cdr(ctorsign),
                                                          predname, output);


  // Overload ctor name with constructor of a record form above
  opi::value ovctorargs = opi::nil;
  opi::value ovctorargnames = opi::nil;
  for (int i = 0; opi::value argtype : range(cdr(ctorsign)))
  {
    opi::value argname = opi::sym(std::format("p{}", i++));
    ovctorargnames = append_mut(ovctorargnames, list(argname));
    ovctorargs = append_mut(ovctorargs, list(list(argname, argtype)));
  }
  *output++ = list("define-overload", list(ctorname, opi::dot, ovctorargs),
                list(recordname, opi::dot, ovctorargnames));

  // Matching rules
  const opi::value unpackdef = generate_unpack_definition(recorddef, unpackname);
  *output++ = list("pragma", "scheme-translator",
                    list("inline", unpackdef),
                    list("cases-rule", mangledctorsign, typesign, predname, unpackname));

  // Generate Prolog predicates
  const opi::value matchpred =
      list("predicate", list("match-on", mangledctorsign, typesign));

  *output++ = list("pragma", "prolog", matchpred);
}


template <std::output_iterator<opi::value> Output>
static void
generate_variant_type(opi::value typesign, opi::value variants, Output output,
                      const opi::source_location &location)
{
  for (const opi::value ctorsign : range(variants))
    generate_variant(typesign, ctorsign, output, location);
}


static opi::value
overloaded_getter_name(opi::value fieldname)
{
  const opi::value result = opi::sym(std::format("osl:#{}", fieldname));
  copy_location(fieldname, result);
  return result;
}

static opi::value
overloaded_setter_name(opi::value fieldname)
{
  const opi::value result = opi::sym(std::format("osl:#set-{}!", fieldname));
  copy_location(fieldname, result);
  return result;
}

template <std::output_iterator<opi::value> Output>
static void
generate_record_type(opi::value typesign, opi::value fields, Output output,
                     const opi::source_location &location)
{
  const opi::value recordname = issym(typesign) ? typesign : car(typesign);

  opi::value fieldnames = opi::nil;
  opi::value fieldtypes = opi::nil;
  for (const opi::value field : range(fields))
  {
    fieldnames = append(fieldnames, list(car(field)));
    fieldtypes = append(fieldtypes, list(car(cdr(field))));
  }

  const opi::value mangledname = opi::sym(std::format("osl:{}", recordname));
  const opi::value predname = opi::sym(std::format("{}?", mangledname));
  const opi::value type_name = opi::sym(std::format("<{}>", mangledname));
  set_location(mangledname, location);
  set_location(predname, location);
  set_location(type_name, location);
  const opi::value recorddef =
      generate_record_definition(typesign, type_name,
                                 mangledname, fieldnames, fieldtypes, predname,
                                 output);

  const opi::value define_overload = "define-overload";
  set_location(define_overload, location);
  const opi::value ctordef = list(define_overload, cons(recordname, fieldnames),
                                  cons(mangledname, fieldnames));
  *output++ = ctordef;

  for (const opi::value fieldname : range(fieldnames))
  {
    const auto [getter, setter] = field_accessors(recorddef, fieldname);
    const opi::value ovgetter = overloaded_getter_name(fieldname);
    const opi::value ovsetter = overloaded_setter_name(fieldname);
    const opi::value getterdef = list(define_overload, list(ovgetter, list("x", typesign)), list(getter, "x"));
    const opi::value setterdef = list(define_overload, list(ovsetter, list("x", typesign), "v"), list(setter, "x", "v"));
    set_location(getterdef, location);
    set_location(setterdef, location);
    *output++ = getterdef;
    *output++ = setterdef;
  }
}



struct loop_unroller: public opi::osl::flow_unroller {
  std::string loopname, varname;
  opi::value breakform;

  loop_unroller(const std::string &loopname, const std::string &varname,
                opi::value breakform)
  : loopname {loopname}, varname {varname}, breakform {breakform}
  { }

  std::pair<opi::osl::flow, opi::value>
  make_return([[maybe_unused]] opi::value args) const override
  {
    throw opi::bad_code {"Unimplemented return from a loop"};
  }

  std::pair<opi::osl::flow, opi::value>
  make_break([[maybe_unused]] opi::value args) const override
  {
    using namespace opi;
    return {opi::osl::flow::branch, cons(breakform, args)};
  }

  std::pair<opi::osl::flow, opi::value>
  make_continue([[maybe_unused]] opi::value args) const override
  {
    using namespace opi;
    if (length(args) > 0)
      throw opi::bad_code {"Invalid continue with arguments"};
    return {opi::osl::flow::branch, list(sym(loopname), sym(varname))};
  }
};


struct function_unroller: public opi::osl::flow_unroller {
  std::pair<opi::osl::flow, opi::value>
  make_return([[maybe_unused]] opi::value args) const override
  {
    using namespace opi;
    const value expr = args == opi::nil ? list("void") : cons("values", args);
    return {opi::osl::flow::branch, expr};
  }

  std::pair<opi::osl::flow, opi::value>
  make_break([[maybe_unused]] opi::value args) const override
  {
    throw opi::bad_code {"Unimplemented break from a function"};
  }

  std::pair<opi::osl::flow, opi::value>
  make_continue([[maybe_unused]] opi::value args) const override
  {
    throw opi::bad_code {"Unimplemented continue function"};
  }
};


static opi::value
fix_type_annotations_in_arguments(opi::value l)
{
  if (not ispair(l))
    return l;

  const opi::value tail = fix_type_annotations_in_arguments(cdr(l));

  opi::value head = car(l);
  if (ispair(head) and car(head) == "annotate-type")
    head = cdr(head);
  return cons(head, tail);
}


static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_type_info(opi::value t)
{
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char", opi::list("char", "char")},
    {"uchar", opi::list("unsigned-char", "char")},
    {"short", opi::list("short", "num")},
    {"ushort", opi::list("unsigned-short", "num")},
    {"int", opi::list("int", "num")},
    {"uint", opi::list("unsigned-int", "num")},
    {"long", opi::list("long", "num")},
    {"ulong", opi::list("unsigned-long", "num")},
    {"i8", opi::list("byte", "num")},
    {"u8", opi::list("unsigned-byte", "num")},
    {"i16", opi::list("short", "num")},
    {"u16", opi::list("unsigned-short", "num")},
    {"i32", opi::list("int32", "num")},
    {"u32", opi::list("unsigned-int32", "num")},
    {"i64", opi::list("integer64", "num")},
    {"u64", opi::list("unsigned-integer64", "num")},
    {"void", opi::list("void", "void")},
    {"cstr", opi::list("c-string", "str")},
  };
  return typemap.at(std::string(opi::sym_name(t)));
}

static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_pointer_type_info(opi::value t)
{
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char", opi::list(opi::list("c-pointer", "char"), "i8array")},
    {"uchar", opi::list(opi::list("c-pointer", "unsigned-char"), "u8array")},
    {"short", opi::list(opi::list("c-pointer", "short"), "i16array")},
    {"ushort", opi::list(opi::list("c-pointer", "unsigned-short"), "u16array")},
    {"int", opi::list(opi::list("c-pointer", "int"), "i32array")},
    {"uint", opi::list(opi::list("c-pointer", "unsigned-int"), "u32array")},
    /*{"long", sizeof(long) == 8 ? opi::list("s64vector", "i64array") : opi::list("s32vector", "i32array")},*/
    /*{"ulong", sizeof(long) == 8 ? opi::list("u64vector", "u64array") : opi::list("u32vector", "u32array")},*/
    {"i8", opi::list("s8vector", "i8array")}, // FIXME
    {"u8", opi::list("u8vector", "u8array")}, // FIXME
    {"i16", opi::list("s16vector", "i16array")}, // FIXME
    {"u16", opi::list("u16vector", "u16array")}, // FIXME
    {"i32", opi::list("s32vector", "i32array")}, // FIXME
    {"u32", opi::list("u32vector", "u32array")}, // FIXME
    {"i64", opi::list("s64vector", "i64array")}, // FIXME
    {"u64", opi::list("u64vector", "u64array")}, // FIXME
    {"void", opi::list("c-pointer", "void*")},
  };
  return typemap.at(std::string(opi::sym_name(t)));
}

static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_pointerpointer_type_info(opi::value t)
{
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char", opi::list(opi::list("c-pointer", opi::list("c-pointer", "char")), "cptr")},
    {"uchar", opi::list(opi::list("c-pointer", opi::list("c-pointer", "unsigned-char")), "u8array")},
    {"short", opi::list(opi::list("c-pointer", opi::list("c-pointer", "short")), "i16array")},
    {"ushort", opi::list(opi::list("c-pointer", opi::list("c-pointer", "unsigned-short")), "u16array")},
    {"int", opi::list(opi::list("c-pointer", opi::list("c-pointer", "int")), "i32array")},
    {"uint", opi::list(opi::list("c-pointer", opi::list("c-pointer", "unsigned-int")), "u32array")},
    /*{"long", sizeof(long) == 8 ? opi::list("s64vector", "i64array") : opi::list("s32vector", "i32array")},*/
    /*{"ulong", sizeof(long) == 8 ? opi::list("u64vector", "u64array") : opi::list("u32vector", "u32array")},*/
    {"i8", opi::list("s8vector", "i8array")}, // FIXME
    {"u8", opi::list("u8vector", "u8array")}, // FIXME
    {"i16", opi::list("s16vector", "i16array")}, // FIXME
    {"u16", opi::list("u16vector", "u16array")}, // FIXME
    {"i32", opi::list("s32vector", "i32array")}, // FIXME
    {"u32", opi::list("u32vector", "u32array")}, // FIXME
    {"i64", opi::list("s64vector", "i64array")}, // FIXME
    {"u64", opi::list("u64vector", "u64array")}, // FIXME
    {"void", opi::list(opi::list("c-pointer", "c-pointer"), "void*")},
  };
  return typemap.at(std::string(opi::sym_name(t)));
}

static bool
is_opening_bracket(int c)
{ return c == '(' or c == '[' or c == '{'; }

static int
closing_bracket_for(int c)
{
  assert(is_opening_bracket(c));
  switch (c)
  {
    case '(': return ')';
    case '[': return ']';
    case '{': return '}';
    default: std::terminate();
  }
}

static void
parse_syntax_cases_macro(opi::osl::generic_lexer &lexer, opi::osl::parser &parser)
{
  int big_bracket;
  opi::osl::lexer::token nametoken, token;
  opi::value name;

  lexer.read(nametoken);

  if (not is_opening_bracket(big_bracket = lexer.read(token)))
    throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};

  opi::osl::macro result;
  while (lexer.peek(token) != closing_bracket_for(big_bracket))
  {
    int bracket;
    opi::stl::unordered_map<opi::value, opi::value> paramtypes;

    // Read pattern
    if (not is_opening_bracket(bracket = lexer.read(token)))
      throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};
    osl::syntax *pattern = osl::macro_pattern_parser(paramtypes)
                           .parse_sequence(lexer, closing_bracket_for(bracket));

    if (lexer.read(token) != '=')
      throw opi::bad_code {"Invalid macro syntax, expected '='", token.location};

    // Read rule
    if (not is_opening_bracket(bracket = lexer.read(token)))
      throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};
      opi::osl::syntax *rule = osl::macro_rule_parser()
                               .parse_sequence(lexer, closing_bracket_for(bracket));

    result.emplace_back(pattern, rule, paramtypes);
  }
  lexer.read(token); // read closing bracket

  parser.add_macro({nametoken.type, nametoken.value}, result);
}


%}

%code requires {
  #include "opium/value.hpp"
  #include "opium/source_location.hpp"

  using namespace opi;

  typedef void* yyscan_t;

  struct range_location {
    size_t left = 0, right = 0;
  };

}

%code {
  void
  yyerror(YYLTYPE *loc_p, yyscan_t scnner, const char *what)
  {
    opi::source_location location;
    location.source = g_source;
    location.start = loc_p->left;
    location.end = loc_p->right;
    throw opi::bad_code {what, location};
  }
}


// =============================================================================
//                                Tokens
// Trampolines to steer the parser
%token PARSE_TOPLVL PARSE_IDENT PARSE_EXPR PARSE_STMT PARSE_ATPAT PARSE_EXPAT
%token EXPR STMT ATPAT EXPAT

// General syntax tokens
%token MACRO
%token REQUIRE FOREIGN_INLINE_BEGIN FOREIGN_INLINE_END FOREIGN
%token ASSERT
%token IDENT
%token CAPIDENT
%right MATCH IN RIGHT_ARROW OTHERWIZE
%token BEGIN_STRING STRING_CHUNK END_STRING
%token INTEGER FLOAT BOOLEAN
%token PRAGMA_
%token TYPE
%token SET
%token FN
%token RETURN YIELD
%token EXTERN AS

%right '|'

%nonassoc IF THEN
%right ELSE

%left '='

%nonassoc RETURN_VOID
%nonassoc RETURN_VALUE

%right LET LETREC WHERE

%right FAT_RIGHT_ARROW

%right OR
%right AND
%nonassoc EQ NE
%nonassoc LT LE GT GE
%right ':'
%left '+' '-' '%'
%left '*' '/'
%right NOT UNARY_OPERATOR
%nonassoc DOUBLE_COLUMN
%left '.' '#'

// =============================================================================
//                              Structures
%type ApplExpr Expr Stmt
%type ListOfExprs ListOfArgs
%type SeqOfExprs
%type TopLvlExpr
%type Match MatchClause MatchClauses
%type AtomPattern ExprPattern ListOfExprPatterns
%type String StringChunks
%type Bind ListOfBinds
%type Ctor Ctor_mangled
%type TopLvlSeq TopLvlExpr
%type TypeDef TypeSign CtorSign ListOfCtorSigns TypeParam ListOfTypeParams ListOfFields
%type If
%type Lambda
%type ExprWithOptTypeParam
%type ForeignType ListOfForeignTypes

%nonassoc AFTER_APPLY
%left APPLY
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
%start Entry


%%

Entry
  : PARSE_TOPLVL TopLvlSeq { *g_result_ptr = $2; }
  | PARSE_IDENT IDENT { *g_result_ptr = $2; }
  | PARSE_EXPR Expr { *g_result_ptr = $2; }
  | PARSE_STMT Stmt { *g_result_ptr = $2; }
  | PARSE_ATPAT AtomPattern { *g_result_ptr = $2; }
  | PARSE_EXPAT ExprPattern { *g_result_ptr = $2; }
;

String
  : BEGIN_STRING StringChunks END_STRING {
    std::string result;
    for (const value chunk : range($2))
      std::ranges::copy(str_view(chunk), std::back_inserter(result));
    $$ = str(result);
    bindloc($$, @$);
  }
;

StringChunks
  : { $$ = nil; }
  | STRING_CHUNK StringChunks { $$ = cons($1, $2); }
;

ApplExpr
  : IDENT
  | INTEGER
  | FLOAT
  | BOOLEAN
  | String { $$ = $1; bindloc($$, @$); }
  | '{' SeqOfExprs '}' { $$ = cons("begin", $2); bindloc($$, @$); }
  | '[' ListOfExprs ']' %prec AFTER_APPLY {
    if (length($2) > 0)
      $$ = cons("oslops:list", $2);
    else
      $$ = list("list.EmptyList");
    bindloc($$, @$);
  }
  | Ctor '(' ListOfExprs ')' %prec APPLY {
    $$ = cons($1, $3);
    bindloc($$, @$);
  }
  | Ctor %prec AFTER_APPLY { $$ = list($1); }
  | ApplExpr '(' ListOfArgs ')' %prec APPLY { $$ = cons($1, $3); bindloc($$, @$); }
  | '(' Expr ')' %prec AFTER_APPLY { $$ = $2; }
  | ApplExpr '.' IDENT '(' ListOfExprs ')' {
    $$ = list($3, $1, dot, $5);
    bindloc($$, @$);
  }
  | ApplExpr '#' IDENT { $$ = list(overloaded_getter_name($3), $1); }
  | ApplExpr '[' Expr ']' %prec APPLY {
    const value getter = random_access_getter();
    bindloc(getter, @$);
    $$ = list(getter, $1, $3);
  }
  | ApplExpr DOUBLE_COLUMN TypeParam { $$ = list("annotate-type", $1, $3); }
;

Expr
  : EXPR
  | ApplExpr
  | '_' { $$ = "_"; } // FIXME (why is this an Expr?)
  | SET IDENT '=' Expr { const value set = "set!"; bindloc(set, @1); $$ = list(set, $2, $4); }
  | SET ApplExpr '[' Expr ']' '=' Expr {
    const value setter = random_access_setter();
    bindloc(setter, @1);
    $$ = list(setter, $2, $4, $7);
  }
  | SET ApplExpr '#' IDENT '=' Expr {
    const value setter = overloaded_setter_name($4);
    bindloc(setter, @1);
    $$ = list(setter, $2, $6);
  }
  | ':' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '+' ApplExpr %prec UNARY_OPERATOR { $$ = isnum($2) ? $2 : list($1, $2); }
  | '-' ApplExpr %prec UNARY_OPERATOR { $$ = isnum($2) ? num(-num_val($2)) : list($1, $2); }
  | '*' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '/' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '%' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | EQ ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | NE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | GT ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | LT ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | GE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | LE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | Expr ':' Expr { const value op = ":"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr '+' Expr { const value op = "+"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr '-' Expr { const value op = "-"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr '*' Expr { const value op = "*"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr '/' Expr { const value op = "/"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr '%' Expr { const value op = "%"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr EQ Expr { const value op = "=="; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr NE Expr { const value op = "!="; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr GT Expr { const value op = ">"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr LT Expr { const value op = "<"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr GE Expr { const value op = ">="; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr LE Expr { const value op = "<="; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr AND Expr { const value op = "and"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | Expr OR Expr { const value op = "or"; bindloc(op, @$); $$ = list(op, $1, $3); }
  | NOT Expr { $$ = list("not", $2); bindloc(car($$), @1); }
  | Lambda
  | If
  | Match
  | LET ListOfBinds IN Expr { $$ = list("let", $2, $4); }
  | LETREC ListOfBinds IN Expr { $$ = list("letrec", $2, $4); }
  | Expr WHERE ListOfBinds { $$ = list("letrec", $3, $1); }
  | PRAGMA_ IDENT STRING_CHUNK {
    lisp_parser parser;
    assert(isstr($3));
    std::istringstream buf {std::string(str_view($3))};
    $$ = list("pragma", $2, dot, parser.parse_all(buf));
  }
  | RETURN %prec RETURN_VOID { $$ = list("return"); bindloc($$, @$); }
  | RETURN Expr %prec RETURN_VALUE { $$ = list("return", $2); bindloc($$, @$); }
  | RETURN Expr ',' ListOfExprs %prec RETURN_VALUE {
    const value values = cons($2, $4);
    $$ = cons("return", values);
    bindloc($$, @$);
  }
  | YIELD Expr { const value yield = "yield"; bindloc(yield, @1); $$ = list(yield, $2); }
  | ASSERT '{' SeqOfExprs '}' {
    $$ = list("if", False, cons("begin", $3));
  }
  | ASSERT NOT '{' SeqOfExprs '}' {
    const value lambda = list("lambda", nil, dot, $4);
    const value assertion = list("assert_thunk", lambda);
    $$ = list("annotate-type", assertion, "assertion_failure");
  }
;

Stmt
  : STMT
  | Expr
  | Expr '=' Expr {
    if (issym($1))
    { // define variable
      const value define = "define";
      bindloc(define, @$);
      $$ = list(define, $1, $3);
    }
    else
    {
      const value define = "define-overload";
      const value fixed_signature =
          cons(car($1), fix_type_annotations_in_arguments(cdr($1)));
      bindloc(define, @$);
      if (opi::ispair($3) and car($3) == "begin")
      {
        function_unroller unroller;
        const value body = append(cdr($3), list(list("void")));
        const value unrolledbody = unroller.unroll_block(body, nil, nil).second;
        $$ = list(define, fixed_signature, dot, unrolledbody);
      }
      else
      {
        $$ = list(define, fixed_signature, $3);
      }
    }
  }
  | Expr ',' ListOfExprs '=' Expr {
    const value idents = cons($1, $3);
    const value define = "define-values";
    bindloc(define, @$);
    $$ = list(define, idents, $5);
  }
;

Lambda
  : '(' ListOfArgs ')' FAT_RIGHT_ARROW Expr { $$ = list("lambda", $2, $5); }
  | IDENT FAT_RIGHT_ARROW Expr { $$ = list("lambda", list($1), $3); }
  | '_' FAT_RIGHT_ARROW Expr { $$ = list("lambda", list("_"), $3); }
;

If
  : IF Expr THEN Expr ELSE Expr { $$ = list("if", $2, $4, $6); }
  | IF Expr THEN Expr { $$ = list("if", $2, $4); }
;

Match
  : MATCH ListOfExprs IN MatchClauses {
    // Fix otherwize-clause
    value newclauses = nil;
    const size_t ncols = length($2);
    for (const value clause : range($4))
    {
      if (car(car(clause)) == "otherwize")
      {
        const auto makewild = []() { return sym("_"); };
        opi::stl::vector<value> newpat;
        std::ranges::generate_n(std::back_inserter(newpat), ncols, makewild);
        const value newclause = cons(list(newpat), cdr(clause));
        newclauses = append(newclauses, list(newclause));
      }
      else
        newclauses = append(newclauses, list(clause));
    }
    bindloc(newclauses, @4);
    const value cases = "cases";
    bindloc(cases, @1);
    $$ = list(cases, $2, dot, newclauses);
  }
;

SeqOfExprs
  : { $$ = nil; }
  | Stmt SeqOfExprs %prec AFTER_APPLY { $$ = cons($1, $2); }
;

TopLvlSeq
  : { $$ = nil; }
  | TopLvlExpr TopLvlSeq %prec AFTER_APPLY { $$ = append($1, $2); }
;

TopLvlExpr
  : Stmt { $$ = list($1); }
  | TypeDef
  | REQUIRE String {
    std::filesystem::path filename {str_view($2)};
    if (filename.extension() == "")
      filename += ".osl";

    std::filesystem::path fullpath;
    try {
      fullpath = resolve_path(filename, osl::pathes.begin(), osl::pathes.end());
    }
    catch (const std::runtime_error &exn)
    { throw opi::bad_code {exn.what(), opi::osl::make_location(@$)}; }

    if (not g_current_tree_parser->target().contains(fullpath))
      g_current_tree_parser->load_file(fullpath);

    $$ = nil;
  }
  | EXTERN IDENT DOUBLE_COLUMN TypeSign {
    $$ = list(
      list("pragma", "scheme-translator",
        list("declare", $2, $4))
    );
  }
  | EXTERN IDENT AS IDENT DOUBLE_COLUMN TypeSign {
    $$ = list(
      list("pragma", "scheme-translator",
        list("declare", $2, $6),
        list("inline", list("define", $4, $2))
      )
    );
  }
  | EXTERN IDENT '(' ListOfTypeParams ')' RIGHT_ARROW ListOfTypeParams {
    $$ = list(
      list("pragma", "prolog",
        list("predicate", list("result-of", list($2, dot, $4), dot, $7)))
    );
  }
  | EXTERN IDENT AS IDENT '(' ListOfTypeParams ')' RIGHT_ARROW ListOfTypeParams {
    const size_t nargs = length($6);
    stl::vector<value> wrapper_args;
    for (size_t i = 0; i < nargs; ++i)
    {
      const value arg_name = sym(std::format("x{}", i));
      const value arg_type = list_ref($6, i);
      wrapper_args.push_back(list(arg_name, arg_type));
    }
    $$ = list(
      list("pragma", "prolog",
        list("predicate", list("result-of", cons($2, $6), dot, $9))),
      list("define-overload", cons($4, list(wrapper_args)),
        cons($2, list(std::views::all(wrapper_args) | std::views::transform(opi::car))))
    );
  }
  | EXTERN FOREIGN IDENT AS IDENT '(' ListOfForeignTypes ')' RIGHT_ARROW ForeignType {
    // Example:
    //   extern foreign foo as bar(unsigned int, unsigned int) -> int
    //   (pragma scheme-translator
    //     (inline
    //       (define bar (foreign-safe-lambda int foo int int))))
    //   (pragma prolog
    //     (predicate (result-of (bar num num) num)))
    // TODO: bind locations
    const opi::value chickenrettype = list_ref($10, 0);
    const opi::value oslrettype = list_ref($10, 1);
    opi::value chickentypes, osltypes;
    for (const opi::value t : range($7))
    {
      const value chickentype = list_ref(t, 0);
      const value osltype = list_ref(t, 1);
      chickentypes = append_mut(chickentypes, list(chickentype));
      osltypes = append_mut(osltypes, list(osltype));
    }
    const opi::value p1 =
      list("pragma", "scheme-translator",
        list("inline",
          list("define", $5, list("foreign-safe-lambda", chickenrettype, $3, opi::dot, chickentypes))));
    const opi::value p2 =
      list("pragma", "prolog",
        list("predicate", list("result-of", list($5, opi::dot, osltypes), oslrettype)));
    $$ = list(p1, p2);
  }
  | EXTERN FOREIGN IDENT '(' ListOfForeignTypes ')' RIGHT_ARROW ForeignType {
    // See above but no aliasing
    // TODO: bind locations
    const opi::value chickenrettype = list_ref($8, 0);
    const opi::value oslrettype = list_ref($8, 1);
    opi::value chickentypes, osltypes;
    for (const opi::value t : range($5))
    {
      const value chickentype = list_ref(t, 0);
      const value osltype = list_ref(t, 1);
      chickentypes = append_mut(chickentypes, list(chickentype));
      osltypes = append_mut(osltypes, list(osltype));
    }
    const opi::value p1 =
      list("pragma", "scheme-translator",
        list("inline",
          list("define", $3, list("foreign-safe-lambda", chickenrettype, $3, opi::dot, chickentypes))));
    const opi::value p2 =
      list("pragma", "prolog",
        list("predicate", list("result-of", list($3, opi::dot, osltypes), oslrettype)));
    $$ = list(p1, p2);
  }
  | FOREIGN_INLINE_BEGIN StringChunks FOREIGN_INLINE_END {
    std::string result;
    result += "\n#>\n";
    for (const value chunk : range($2))
    {
      std::ranges::copy(str_view(chunk), std::back_inserter(result));
      result.push_back('\n');
    }
    result += "<#\n";
    $$ = list(
      list("pragma", "scheme-translator",
        list("inline", sym(result))));
    bindloc($$, @$);
  }
  | MACRO {
    parse_syntax_cases_macro(*g_current_lexer, *g_current_tree_parser);
    $$ = nil;
  }
;

TypeDef
  : TYPE TypeSign '=' ListOfCtorSigns {
    opi::stl::vector<value> tape;
    source_location location;
    location.source = g_source;
    location.start = @$.left;
    location.end = @$.right;
    generate_variant_type($2, $4, std::back_inserter(tape), location);
    $$ = list(tape);
    bindloc($$, @$);
  }
  | TYPE TypeSign '=' '{' ListOfFields '}' {
    opi::stl::vector<value> tape;
    
    opi::source_location location;
    location.source = g_source;
    location.start = @$.left;
    location.end = @$.right;
    generate_record_type($2, $5, std::back_inserter(tape), location);
    $$ = list(tape);
    bindloc($$, @$);
  }
;

TypeSign
  : IDENT %prec AFTER_APPLY
  | IDENT '(' ListOfTypeParams ')' %prec APPLY { $$ = cons($1, $3); bindloc($$, @$); }
  | FN '(' ListOfTypeParams ')' RIGHT_ARROW TypeParam {
    const value fn = "fn";
    bindloc(fn, @1);
    $$ = list(fn, $3, $6);
  }
  | FN '(' ListOfTypeParams ')' RIGHT_ARROW '(' ListOfTypeParams ')' {
    const value fn = "fn";
    bindloc(fn, @1);
    $$ = list(fn, $3, dot, $7);
  }
;

ListOfCtorSigns
  : CtorSign { $$ = list($1); }
  | CtorSign '|' ListOfCtorSigns { $$ = cons($1, $3); }
;

CtorSign
  : CAPIDENT '(' ListOfTypeParams ')' %prec APPLY { $$ = cons($1, $3); }
  | CAPIDENT %prec AFTER_APPLY { $$ = list($1); }
;

ListOfTypeParams
  : { $$ = nil; }
  | TypeParam { $$ = list($1); }
  | TypeParam ',' ListOfTypeParams { $$ = cons($1, $3); }
;

TypeParam
  : CAPIDENT
  | TypeSign
  | '_' { $$ = "_"; }
;

ListOfFields
  : { $$ = nil; }
  | IDENT TypeParam { $$ = list(list($1, $2)); }
  | IDENT TypeParam ',' ListOfFields { $$ = cons(list($1, $2), $4); }
;

ListOfExprs
  : { $$ = nil; }
  | Expr { $$ = list($1); }
  | Expr ',' ListOfExprs { $$ = cons($1, $3); }
;

ListOfArgs
  : { $$ = nil; }
  | ExprWithOptTypeParam { $$ = list($1); }
  | ExprWithOptTypeParam ',' ListOfArgs { $$ = cons($1, $3); }
;

ExprWithOptTypeParam
  : Expr
  | Expr TypeParam { $$ = list($1, $2); }
;


MatchClauses
  : MatchClause { $$ = list($1); }
  | MatchClause MatchClauses { $$ = cons($1, $2); }
;

MatchClause
  : '|' ListOfExprPatterns RIGHT_ARROW Expr { $$ = cons($2, list($4)); }
  | '|' OTHERWIZE RIGHT_ARROW Expr { $$ = cons(list("otherwize"), list($4)); }
;

ListOfExprPatterns
  : { $$ = nil; }
  | ExprPattern { $$ = list($1); }
  | ExprPattern ',' ListOfExprPatterns { $$ = cons($1, $3); }
;

ExprPattern
  : EXPAT
  | AtomPattern
  | ExprPattern ':' ExprPattern {
    const value Cons = mangle_type_constructor("Cons");
    bindloc(Cons, @2);
    $$ = list(Cons, $1, $3);
  }
;

AtomPattern
  : ATPAT
  | IDENT
  | '(' ExprPattern ')' { $$ = $2; }
  | Ctor_mangled %prec AFTER_APPLY { $$ = list($1); }
  | Ctor_mangled '(' ListOfExprPatterns ')' %prec APPLY { $$ = cons($1, $3); }
  | '[' ']' {
    const value EmptyList = mangle_type_constructor("EmptyList");
    bindloc(EmptyList, @$);
    $$ = list(EmptyList);
  }
;


ListOfBinds
  : Bind { $$ = list($1); }
  | Bind ',' ListOfBinds { $$ = cons($1, $3); }
;

Bind
  : IDENT '=' Expr { $$ = list($1, $3); }
  | IDENT '(' ListOfExprs ')' '=' Expr {
    const value lambda = "lambda";
    bindloc(lambda, @$);
    value lambdaexpr;
    if (ispair($6) and car($6) == "begin")
    {
      function_unroller unroller;
      const value body = append(cdr($6), list(list("void")));
      const value unrolledbody = unroller.unroll_block(body, nil, nil).second;
      lambdaexpr = list(lambda, $3, dot, unrolledbody);
    }
    else
      lambdaexpr = list(lambda, $3, $6);
    $$ = list($1, lambdaexpr);
  }
;

Ctor_mangled
  : CAPIDENT { $$ = mangle_type_constructor($1); }
;
Ctor
  : CAPIDENT { $$ = $1; }
;

ForeignType
  : IDENT { $$ = foreign_type_info($1); }
  | IDENT '*' { $$ = foreign_pointer_type_info($1); }
  | IDENT '*' '*' { $$ = foreign_pointerpointer_type_info($1); }
;

ListOfForeignTypes
  : { $$ = opi::nil; }
  | ForeignType { $$ = list($1); }
  | ForeignType ',' ListOfForeignTypes { $$ = cons($1, $3); }
;

%%

typedef void* yyscan_t;

extern int
yylex_init(yyscan_t *scanner);

extern void
yyset_in(FILE *in, yyscan_t scanner);

extern void
yylex_destroy(yyscan_t scanner);


static void
bindloc(opi::value val, const range_location &loc)
{
  opi::source_location location;
  location.source = g_source;
  location.start = loc.left;
  location.end = loc.right;
  opi::set_location(val, location);
}

opi::source_location
opi::osl::make_location(const range_location &loc)
{
  opi::source_location location;
  location.source = g_source;
  location.start = loc.left;
  location.end = loc.right;
  return location;
}

namespace opi::osl {

opi::value
opi::osl::parser::parse(int entry_token, generic_lexer &lexer, bool force)
{
  opi::utl::state_saver _ {g_result_ptr, g_current_lexer};

  opi::value result = nil;
  g_result_ptr = &result;

  g_current_lexer = &lexer;

  int status;
  bool enforced = false;
  yypstate *ps = yypstate_new();
  lexer.put(entry_token);
  do {
L_read_next:
    // Read next token
    lexer::token token;
    lexer.read(token);

    // Handle macros
    auto [begin, end] = m_macros.equal_range({token.type, token.value});
    for (const auto &[_, macro] : std::ranges::subrange(begin, end))
    {
      for (const macro_case &mcase : macro)
      {
        opi::stl::unordered_map<opi::value, opi::value> paramvals;

        // Put the macro-trigger token back and run the macro
        stateful_lexer stlexer {lexer};
        stateful_lexer::state lexst = stlexer.current_state();
        try
        {
          debug("testing macro {}", token.value);
          stlexer.put(token);
          macro_pattern_matcher(mcase.paramtypes, paramvals)
            .match_syntax(stlexer, *this, mcase.pattern);
          macro_expander(mcase.paramtypes, paramvals)
            .expand(stlexer, mcase.rule);
          debug("successfuly aplied macro {}", token.value);
          goto L_read_next;
        }
        catch (...)
        {
          debug("recovering lexer state after failed attempt to use macro {}",
                token.value);
          stlexer.recover_state(lexst);
          lexer::token nexttoken;
          lexer.peek(nexttoken);
          debug("next token: {}", nexttoken.value);
        }
      }
    }

    // Convert token into bison's representatoin
    value yylval = token.value;
    range_location yyloc {token.location.start, token.location.end};

    try {
      // Run one parser iteration
      status = yypush_parse(ps, token.type, &yylval, &yyloc, nullptr);
    }
    catch (...) { // FIXME: must catch exceptions from yyerror and let the rest through
      if (force and not enforced)
      { // Put back the last token weve read and inject and EOF to force parser
        // to finish
        lexer.put(token);
        lexer.put(YYEOF);
        enforced = true;
        continue;
      }
      else
        throw;
    }
  } while (status == YYPUSH_MORE);
  yypstate_delete(ps);

  return result;
}


void
tree_parser::load_source(const std::string &source, std::FILE *file)
{
  opi::utl::state_saver _ {g_source, g_current_tree_parser};
  g_source = source;
  g_current_tree_parser = this;

  lexer scanner {{source, 0, 0}, file};
  const opi::value result = parse(PARSE_TOPLVL, scanner);
  m_target.append(source, result);
}

} // namespace opi::osl
