%require "3.2"
%language "C"

%define parse.error verbose
%define lr.type ielr
%define parse.lac full
%define api.value.type { opi::value }

%define api.pure full
%define api.push-pull push
%param { yyscan_t scanner }
%locations
%define api.location.type { range_location }

%{
#include "parse.hpp"
#include "unroll_flow.hpp"
#include "macros.hpp"

#include "opium/value.hpp"
#include "opium/logging.hpp"
#include "opium/pretty_print.hpp"
#include "opium/stl/vector.hpp"
#include "opium/lisp_parser.hpp"
#include "opium/utilities/ranges.hpp"
#include "opium/utilities/state_saver.hpp"
#include "opium/utilities/path_resolver.hpp"
#include "opium/stl/unordered_map.hpp"
#include "opium/hash.hpp"

#include <unordered_set>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <filesystem>
#include <cassert>


static opi::value* g_result_ptr;
static int g_counter = 0;

#define YYMALLOC opi::allocate
#define YYREALLOC GC_realloc
#define YYFREE GC_free
#define YYSTACK_USE_ALLOCA 1

#define YYLLOC_DEFAULT(Cur, Rhs, N)                    \
do {                                                   \
  if (N)                                               \
  {                                                    \
    (Cur).left = YYRHSLOC(Rhs, 1).left;                \
    (Cur).right = YYRHSLOC(Rhs, N).right;              \
  }                                                    \
  else                                                 \
  {                                                    \
    (Cur).left = (Cur).right = YYRHSLOC(Rhs, 0).right; \
  }                                                    \
} while (0)


struct range_location;

namespace opi::osl {

std::vector<std::string> pathes = {"."};

opi::source_location
make_location(const range_location &loc);

static
std::optional<int> start_token;

static
std::optional<YYLTYPE> start_location;

}

static
opi::osl::generic_lexer *g_current_lexer;

static
opi::osl::program_parser *g_current_program_parser;


static std::string g_source;

static void
bindloc(opi::value val, const range_location &loc);

static opi::value
mangle_type_constructor(opi::value ctor)
{
  const opi::value result = opi::sym("osl#ctor#" + std::string(opi::sym_name(ctor)));
  copy_location(ctor, result);
  return result;
}


static opi::value
random_access_getter()
{ return "osl#ref"; }


static opi::value
random_access_setter()
{ return "osl#set"; }


static opi::value
generate_inlinescm_lambda(opi::value scmexpr, opi::value argtypes,
                          opi::value restypes)
{
  return
    list("annotate-type",
      list("pragma", "inline-scheme", scmexpr),
      list("fn", argtypes, dot, restypes));
}


static opi::value
generate_record_definition(opi::value name, opi::value ctorname,
                           opi::value fields, opi::value predname,
                           opi::scheme_translator &translator)
{
  // Getters and setters
  opi::value accessors = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value gettername = opi::sym(std::format("{:r}-{:r}", ctorname, field));
    const opi::value settername = opi::sym(std::format("{:r}-set-{:r}!", ctorname, field));
    copy_location(field, gettername);
    copy_location(field, settername);
    accessors = append(accessors, list(list(field, gettername, settername)));
  }

  // Write define-record-type expression
  const opi::value recorddef = list("define-record-type", name,
                                    cons(ctorname, fields), predname,
                                    opi::dot, accessors);
  const opi::value fastrecorddef = list("define-record-type-variant", name,
                                        opi::list("unsafe", "unchecked", "inline"),
                                        cons(ctorname, fields), predname,
                                        opi::dot, accessors);
  append_mut(translator.prologue, list(recorddef, fastrecorddef));

  return recorddef;
}


static opi::value
record_ctor(opi::value recorddef)
{ return car(recorddef[2]); }

static opi::value
record_fields(opi::value recorddef)
{ return cdr(recorddef[2]); }

static opi::value
record_predicate(opi::value recorddef)
{ return recorddef[3]; }


static std::pair<opi::value, opi::value>
record_field_accessors(opi::value recorddef, opi::value field)
{
  const opi::value accessors = cdr(cdr(cdr(cdr(recorddef))));
  opi::value fieldaccessors;
  if (not assoc(field, accessors, fieldaccessors))
    throw std::runtime_error {std::format("No accessors for field {}", field)};
  return {car(fieldaccessors), car(cdr(fieldaccessors))};
}



static void
generate_unpack_definition(opi::value recorddef, opi::value unpackname,
                           opi::scheme_translator &translator)
{
  const opi::value signature = car(cdr(cdr(recorddef)));
  const opi::value fields = cdr(signature);

  opi::value args = opi::nil;
  for (const opi::value field : opi::range(fields))
  {
    const opi::value getter = record_field_accessors(recorddef, field).first;
    const opi::value getfield = list(getter, "x");
    args = append(args, list(getfield));
  }

  const opi::value unpackdef =
    list("define", list(unpackname, "x"), cons("values", args));
  append_mut(translator.prologue, list(unpackdef));
}




static opi::value
overloaded_getter_name(opi::value fieldname)
{
  const opi::value result = opi::sym(std::format("osl#{:r}-ref", fieldname));
  copy_location(fieldname, result);
  return result;
}

static opi::value
overloaded_setter_name(opi::value fieldname)
{
  const opi::value result = opi::sym(std::format("osl#{:r}-set!", fieldname));
  copy_location(fieldname, result);
  return result;
}

template <std::output_iterator<opi::value> Output>
static void
generate_record_interface(opi::value recorddef,
                          opi::value typesign,
                          opi::value fieldtypes,
                          opi::value ovctorname,
                          const opi::source_location &location,
                          opi::scheme_translator &translator,
                          Output output)
{
  const value constructor = record_ctor(recorddef);
  const value fieldnames = record_fields(recorddef);
  const value predicate = record_predicate(recorddef);

  translator.match_translation.add_rule(list(list("typename", typesign),"_"),
                                        "_", predicate, "identity");

  value ctorargs = nil;
  for (const auto [fieldname, fieldtype] : utl::zip(range(fieldnames), range(fieldtypes)))
    append_mut(ctorargs, list(list(fieldname, fieldtype)));

  const opi::value define_overload = "define-overload";
  set_location(define_overload, location);
  const opi::value ctordef =
    list(define_overload, cons(ovctorname, ctorargs),
      list(generate_inlinescm_lambda(constructor, fieldtypes, list(typesign)),
           dot, fieldnames));
  *output++ = ctordef;

  for (const auto [fieldname, fieldtype] : opi::utl::zip(range(fieldnames), range(fieldtypes)))
  {
    const auto [getter, setter] = record_field_accessors(recorddef, fieldname);
    const opi::value ovgetter = overloaded_getter_name(fieldname);
    const opi::value ovsetter = overloaded_setter_name(fieldname);
    const opi::value getterdef =
      list(define_overload, list(ovgetter, list("x", typesign)),
        list(generate_inlinescm_lambda(getter, list(typesign), list(fieldtype)),
             "x"));
    const opi::value setterdef =
      list(define_overload, list(ovsetter, list("x", typesign), list("v", fieldtype)),
        list(generate_inlinescm_lambda(setter, list(typesign, fieldtype), list("void")),
             "x", "v"));
    set_location(getterdef, location);
    set_location(setterdef, location);
    *output++ = getterdef;
    *output++ = setterdef;
  }
}


template <std::output_iterator<opi::value> Output>
static void
generate_variant(opi::value typesign, opi::value ctorsign,
                 const opi::source_location &location,
                 opi::scheme_translator &translator, Output output)
{
  // NOTE: Don't allow overloading constructors for now
  //       (no particular reason, just a design decision; can change it later)
  const opi::value enumname = issym(typesign) ? typesign : car(typesign);
  const opi::value type_name = sym(std::format("{:r}.{:r}", enumname, car(ctorsign)));
  const opi::value ctorname = car(ctorsign);
  const opi::value scmtypename = opi::sym(std::format("osl#{:r}", type_name));
  const opi::value scmctorname = opi::sym(std::format("osl#ctor#{:r}.{:r}", type_name, ctorname));
  const opi::value scmpredname = opi::sym(std::format("{:r}?", scmtypename));
  const opi::value unpackname = opi::sym(std::format("unpack-{:r}", scmtypename));
  const opi::value fieldtypes = cdr(ctorsign);
  opi::value fieldnames = opi::nil;
  for (size_t i = 0; i < length(cdr(ctorsign)); ++i)
  {
    const opi::value fieldname {std::format("value{}", i).c_str()};
    append_mut(fieldnames, list(fieldname));
  }

  // Generate record for this variant
  const opi::value recorddef =
    generate_record_definition(scmtypename, scmctorname, fieldnames, scmpredname,
                               translator);

  generate_record_interface(recorddef, typesign, fieldtypes, ctorname,
                            location, translator, output);

  // Matching rules
  const value mctorname = mangle_type_constructor(ctorname);
  const value mctorsign = cons(mctorname, cdr(ctorsign));
  generate_unpack_definition(recorddef, unpackname, translator);
  translator.match_translation.add_rule(mctorsign, typesign, scmpredname, unpackname);

  // Generate Prolog predicates
  translator.prolog << list("predicate", list("match-on", mctorsign, typesign));
}


template <std::output_iterator<opi::value> Output>
static void
generate_variant_type(opi::value typesign, opi::value variants,
                      const opi::source_location &location,
                      opi::scheme_translator &translator,
                      Output output)
{
  for (const opi::value ctorsign : range(variants))
    generate_variant(typesign, ctorsign, location, translator, output);
}



struct function_unroller: public opi::osl::flow_unroller {
  using flow_unroller::flow_unroller;

  std::pair<opi::osl::flow, opi::value>
  make_return([[maybe_unused]] opi::value args) const override
  {
    using namespace opi;

    value expr;
    if (args == opi::nil)
      expr = list("void");
    else if (length(args) == 1)
      expr = car(args);
    else
      expr = cons("values", args);
    return {opi::osl::flow::branch, expr};
  }
};


template <typename Out>
static void
find_return_exprs(opi::value returnident, opi::value x, Out out)
{
  if (ispair(x))
  {
    if (car(x) == returnident)
      *out++ = x;
    else
    {
      find_return_exprs(returnident, car(x), out);
      find_return_exprs(returnident, cdr(x), out);
    }
  }
}


static opi::value
make_body_with_return(opi::value body)
{
  opi::stl::vector<opi::value> origreturns;
  find_return_exprs("__RETURN", body, std::back_inserter(origreturns));

  // NOP if there are no return expressions
  if (origreturns.empty())
    return body;

  // Try unrolling the body by following simple control flow
  // NOTE: may fail to detect return expression in some cases, but when it works
  //       we take it
  function_unroller unroller {"__RETURN"};
  const value fastbody = append(body, list(list("void")));
  const value unrolledbody = unroller.unroll_block(fastbody, nil, nil).second;
  opi::stl::vector<opi::value> unrolledreturns;
  find_return_exprs("__RETURN", unrolledbody, std::back_inserter(unrolledreturns));
  if (unrolledreturns.empty())
    // No return expressions left, means fast approach worked out
    return unrolledbody;
  
  // For complicated cases, wrap the body into a `call/cc` and use the exitation
  // to implement return expressions.
  // TODO: handle missing return statement at the end of the non-void body
  size_t nreturns = length(cdr(origreturns.front()));
  for (const opi::value rexpr : origreturns)
  {
    if (length(cdr(rexpr)) != nreturns)
      throw opi::bad_code {"Inconsistent number of return values", body};
  }
  switch (nreturns)
  {
    case 0:
      for (opi::value rexpr : origreturns)
      {
        set_car(rexpr, "__Return");
        set_cdr(rexpr, list(list("void")));
      }
      return
        list(
          list("__callcc",
            list("lambda", list("__Return"), dot, body)));
      
    case 1:
      for (opi::value rexpr : origreturns)
        set_car(rexpr, "__Return");
      return
        list(
          list("__callcc",
            list("lambda", list("__Return"), dot, body)));

    default:
      for (opi::value rexpr : origreturns)
      {
        set_car(rexpr, "__Return");
        set_cdr(rexpr, list(cons("pack", cdr(rexpr))));
      }
      return
        list(
          list("unpack",
            list("__callcc",
              list("lambda", list("__Return"), dot, body))));
  }
}


static opi::value
fix_type_annotations_in_arguments(opi::value l)
{
  if (not ispair(l))
    return l;

  const opi::value tail = fix_type_annotations_in_arguments(cdr(l));

  opi::value head = car(l);
  if (ispair(head) and car(head) == "annotate-type")
    head = cdr(head);
  return cons(head, tail);
}


static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_type_info(opi::value t)
{
  using opi::list;
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char",   list("char",               "char")},
    {"uchar",  list("unsigned-char",      "char")},
    {"short",  list("short",              "num")},
    {"ushort", list("unsigned-short",     "num")},
    {"int",    list("int",                "num")},
    {"uint",   list("unsigned-int",       "num")},
    {"long",   list("long",               "num")},
    {"ulong",  list("unsigned-long",      "num")},
    {"float",  list("float",              "num")},
    {"double", list("double",             "num")},
    {"i8",     list("byte",               "num")},
    {"u8",     list("unsigned-byte",      "num")},
    {"i16",    list("short",              "num")},
    {"u16",    list("unsigned-short",     "num")},
    {"i32",    list("int32",              "num")},
    {"u32",    list("unsigned-int32",     "num")},
    {"i64",    list("integer64",          "num")},
    {"u64",    list("unsigned-integer64", "num")},
    {"f32",    list("float",              "num")},
    {"f64",    list("double",             "num")},
    {"void",   list("void",               "void")},
    {"cstr",   list("c-string",           list("?", "str"))},
    {"blob",   list("blob",               "blob")},
  };
  try { return typemap.at(std::string(opi::sym_name(t))); }
  catch (...) { throw opi::bad_code {"Invalid foreign type specifier", t}; }
}

static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_pointer_type_info(opi::value t)
{
  using opi::list;
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char",   list(list("c-pointer", "char"),               list("ptr", "i8"))},
    {"uchar",  list(list("c-pointer", "unsigned-char"),      list("ptr", "u8"))},
    {"short",  list(list("c-pointer", "short"),              list("ptr", "i16"))},
    {"ushort", list(list("c-pointer", "unsigned-short"),     list("ptr", "u16"))},
    {"int",    list(list("c-pointer", "int"),                list("ptr", "i32"))},
    {"uint",   list(list("c-pointer", "unsigned-int"),       list("ptr", "u32"))},
    {"long",   list(list("c-pointer", "long"),               list("ptr", sizeof(long) == 8 ? "i64" : "i32"))},
    {"ulong",  list(list("c-pointer", "unsigned-long"),      list("ptr", sizeof(long) == 8 ? "u64" : "i64"))},
    {"float",  list(list("c-pointer", "float"),              list("ptr", "f32"))},
    {"double", list(list("c-pointer", "double"),             list("ptr", "f64"))},
    {"i8",     list(list("c-pointer", "byte"),               list("ptr", "i8"))},
    {"u8",     list(list("c-pointer", "unsigned-byte",       list("ptr", "u8")))},
    {"i16",    list(list("c-pointer", "short"),              list("ptr", "i16"))},
    {"u16",    list(list("c-pointer", "unsigned-short"),     list("ptr", "u16"))},
    {"i32",    list(list("c-pointer", "int32"),              list("ptr", "i32"))},
    {"u32",    list(list("c-pointer", "unsigned-int32"),     list("ptr", "u32"))},
    {"i64",    list(list("c-pointer", "integer64"),          list("ptr", "i64"))},
    {"u64",    list(list("c-pointer", "unsigned-integer64"), list("ptr", "u64"))},
    {"f32",    list(list("c-pointer", "float"),              list("ptr", "f32"))},
    {"f64",    list(list("c-pointer", "double"),             list("ptr", "f64"))},
    {"void",   list("c-pointer",                             list("ptr", "void"))},
  };
  try { return typemap.at(std::string(opi::sym_name(t))); }
  catch (...) { throw opi::bad_code {"Invalid foreign type pointer-specifier", t}; }
}

static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_array_type_info(opi::value t)
{
  using opi::list;
  static opi::stl::unordered_map<std::string, opi::value> typemap {
    {"char",    list("s8vector",  "i8array")},
    {"uchar",   list("u8vector",  "i8array")},
    {"short",   list("s16vector", "i16array")},
    {"ushort",  list("u16vector", "i16array")},
    {"int",     list("s32vector", "i32array")},
    {"uint",    list("u32vector", "u32array")},
    {"long",    sizeof(long) == 8 ?
                list("s64vector", "i64array") :
                list("s32vector", "i32array")},
    {"ulong",   sizeof(long) == 8 ?
                list("u64vector", "u64array") :
                list("u32vector", "u32array")},
    {"i8",      list("s8vector",  "i8array")},
    {"u8",      list("u8vector",  "u8array")},
    {"i16",     list("s16vector", "i16array")},
    {"u16",     list("u16vector", "u16array")},
    {"i32",     list("s32vector", "i32array")},
    {"u32",     list("u32vector", "u32array")},
    {"i64",     list("s64vector", "i64array")},
    {"u64",     list("u64vector", "u64array")},
    {"f32",     list("f32vector", "f32array")},
    {"f64",     list("f64vector", "f64array")},
  };
  try { return typemap.at(std::string(opi::sym_name(t))); }
  catch (...) { throw opi::bad_code {"Invalid foreign type array-specifier", t}; }
}

static opi::value // (<chicken-foreign-type>, <osl-type>)
foreign_pointerpointer_type_info(opi::value t)
{
  using opi::list;
  using opi::list_ref;

  const opi::value tinfo = foreign_pointer_type_info(t);
  return list(
    list("c-pointer", opi::list_ref(tinfo, 0)),
    list("ptr", opi::list_ref(tinfo, 1))
  );
}

static bool
is_opening_bracket(int c)
{ return c == '(' or c == '[' or c == '{'; }

static int
closing_bracket_for(int c)
{
  assert(is_opening_bracket(c));
  switch (c)
  {
    case '(': return ')';
    case '[': return ']';
    case '{': return '}';
    default: std::terminate();
  }
}

static void
parse_syntax_cases_macro(opi::osl::generic_lexer &lexer, opi::osl::parser &parser)
{
  int big_bracket;
  opi::osl::lexer::token nametoken, token;
  opi::value name;

  lexer.read(nametoken);

  if (not is_opening_bracket(big_bracket = lexer.read(token)))
    throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};

  opi::osl::macro result;
  while (lexer.peek(token) != closing_bracket_for(big_bracket))
  {
    int bracket;
    opi::stl::unordered_map<opi::value, opi::value> paramtypes;

    // Read pattern
    if (not is_opening_bracket(bracket = lexer.read(token)))
      throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};
    osl::syntax *pattern = osl::macro_pattern_parser(paramtypes)
                           .parse_sequence(lexer, closing_bracket_for(bracket));

    if (lexer.read(token) != '=')
      throw opi::bad_code {"Invalid macro syntax, expected '='", token.location};

    // Read rule
    if (not is_opening_bracket(bracket = lexer.read(token)))
      throw opi::bad_code {"Invalid macro syntax, expected opening bracket", token.location};
      opi::osl::syntax *rule = osl::macro_rule_parser()
                               .parse_sequence(lexer, closing_bracket_for(bracket));

    result.emplace_back(pattern, rule, paramtypes);
  }
  lexer.read(token); // read closing bracket

  parser.add_macro({nametoken.type, nametoken.value}, result);
}


%}

%code requires {
  #include "opium/value.hpp"
  #include "opium/source_location.hpp"

  using namespace opi;

  typedef void* yyscan_t;

  struct range_location {
    size_t left = 0, right = 0;
  };

}

%code {
  void
  yyerror(YYLTYPE *loc_p, yyscan_t scnner, const char *what)
  {
    opi::source_location location;
    location.source = g_source;
    location.start = loc_p->left;
    location.end = loc_p->right;
    throw opi::osl::parse_error {what, location};
  }
}


// =============================================================================
//                                Tokens
// Trampolines to steer the parser
%token PARSE_TOPLVL PARSE_IDENT PARSE_EXPR PARSE_STMT PARSE_ATPAT PARSE_EXPAT
%token PARSE_ATTYPE PARSE_EXTYPE PARSE_APPL
%token APPL EXPR STMT ATPAT EXPAT ATTYPE EXTYPE

// General syntax tokens
%token INLINE_TYPCHECK
%token MACRO
%token REQUIRE
%token FOREIGN_INLINE_BEGIN FOREIGN_INLINE_END FOREIGN
%token SCHEME_INLINE_BEGIN SCHEME_INLINE_END SCHEME
%token INLINE_SCHEME
%token ASSERT
%token IDENT
%token CAPIDENT
%right MATCH IN RIGHT_ARROW OTHERWIZE
%token BEGIN_STRING STRING_CHUNK END_STRING
%token INTEGER FLOAT BOOLEAN CHAR
%token PRAGMA_
%token TYPE
%token SET
%token FN
%token EXTERN AS

%right '|' '&'

%nonassoc IF THEN
%right ELSE

%left '='

%right LET LETREC WHERE

%right FAT_RIGHT_ARROW

%right OR
%right AND
%nonassoc EQ NE
%nonassoc LT LE GT GE
%right ':'
%left '+' '-' '%'
%left '*' '/'
%right NOT UNARY_OPERATOR
%nonassoc DOUBLE_COLUMN
%left '[' ']'
%left '.' '#'
%left '?'

// =============================================================================
//                              Structures
%type ApplExpr Expr Stmt
%type ListOfExprs ListOfArgs NonZeroListOfIdents
%type SeqOfStmts
%type TopLvlExpr
%type Match MatchClause MatchClauses
%type AtomPattern ExprPattern ListOfExprPatterns
%type String StringChunks
%type Bind ListOfBinds
%type TopLvlSeq TopLvlExpr
%type TypeDef
%type TypeSign CtorSign ListOfCtorSigns TypeParam ListOfTypeParams
%type ListOfFields
%type If
%type Lambda
%type ExprWithOptTypeParam
%type ForeignType ListOfForeignTypes

%nonassoc AFTER_APPLY
%left APPLY
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
%start Entry


%%

Entry
  : PARSE_TOPLVL TopLvlSeq { *g_result_ptr = $2; }
  | PARSE_IDENT IDENT { *g_result_ptr = $2; }
  | PARSE_APPL ApplExpr { *g_result_ptr = $2; }
  | PARSE_EXPR Expr { *g_result_ptr = $2; }
  | PARSE_STMT Stmt { *g_result_ptr = $2; }
  | PARSE_ATPAT AtomPattern { *g_result_ptr = $2; }
  | PARSE_EXPAT ExprPattern { *g_result_ptr = $2; }
  | PARSE_ATTYPE AtomTypeParam { *g_result_ptr = $2; }
  | PARSE_EXTYPE TypeParam { *g_result_ptr = $2; }
;

String
  : BEGIN_STRING StringChunks END_STRING {
    std::string result;
    for (const value chunk : range($2))
      std::ranges::copy(str_view(chunk), std::back_inserter(result));
    $$ = str("s:" + result);
    bindloc($$, @$);
  }
;

StringChunks
  : { $$ = nil; }
  | STRING_CHUNK StringChunks { $$ = cons($1, $2); }
;

ApplExpr
  : APPL
  | IDENT
  | INTEGER
  | FLOAT
  | BOOLEAN
  | CHAR
  | '_' {
    $$ = sym(std::format("osl#unanimous#{}", g_counter++));
  }
  | String { $$ = $1; bindloc($$, @$); }
  | '{' SeqOfStmts '}' { $$ = cons("begin", $2); bindloc($$, @$); }
  | '[' ListOfExprs ']' %prec AFTER_APPLY {
    $$ = cons("osl#list", $2);
    bindloc($$, @$);
  }
  | CAPIDENT '(' ListOfExprs ')' %prec APPLY {
    $$ = cons($1, $3);
    bindloc($$, @$);
  }
  | CAPIDENT %prec AFTER_APPLY { $$ = list($1); }
  | ApplExpr '(' ListOfArgs ')' %prec APPLY {
    opi::set_location($3, *$2->location + *$4->location);
    $$ = cons($1, $3);
    /*opi::set_location($$, *$1->location + *$4->location);*/
  }
  | '(' Expr ')' %prec AFTER_APPLY { $$ = $2; }
  | ApplExpr '.' IDENT '(' ListOfExprs ')' {
    opi::set_location($5, *$3->location + *$6->location);
    $$ = list($3, $1, dot, $5);
    opi::set_location($$, *$2->location + *$6->location);
  }
  | ApplExpr '#' IDENT { $$ = list(overloaded_getter_name($3), $1); }
  | ApplExpr '[' Expr ']' %prec APPLY {
    const value getter = random_access_getter();
    opi::set_location(getter, *$2->location + *$4->location);
    $$ = list(getter, $1, $3);
  }
  | ApplExpr DOUBLE_COLUMN AtomTypeParam { $$ = list("annotate-type", $1, $3); }
  | INLINE_SCHEME {
    opi::lisp_parser parser;
    try {
      const value sexpr = parser.parse(str_view($1).data());
      const value inlinescm = list("pragma", "inline-scheme", sexpr);
      $$ = list("annotate-type", inlinescm, "inline-scheme-result");
    }
    catch (const std::exception &exn)
    {
      opi::error("while parsing inline scheme block: {}\n{}", exn.what(),
                 opi::display_location(osl::make_location(@$)));
      throw;
    }
  }
;

Expr
  : EXPR
  | ApplExpr
  | SET IDENT '=' Expr { const value set = "set!"; opi::copy_location($1, set); $$ = list(set, $2, $4); }
  | SET ApplExpr '[' Expr ']' '=' Expr {
    const value setter = random_access_setter();
    opi::copy_location($1, setter);
    $$ = list(setter, $2, $4, $7);
  }
  | SET ApplExpr '#' IDENT '=' Expr {
    const value setter = overloaded_setter_name($4);
    opi::copy_location($1, setter);
    $$ = list(setter, $2, $6);
  }
  | SET '*' ApplExpr '=' Expr {
    const value store = "osl#store";
    opi::copy_location($1, store);
    $$ = list(store, $3, $5);
  }
  | ':' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '+' ApplExpr %prec UNARY_OPERATOR { $$ = isnum($2) ? $2 : list($1, $2); }
  | '-' ApplExpr %prec UNARY_OPERATOR { $$ = isnum($2) ? num(-num_val($2)) : list($1, $2); }
  | '*' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '/' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '%' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | EQ ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | NE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | GT ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | LT ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | GE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | LE ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | '&' ApplExpr %prec UNARY_OPERATOR { $$ = list($1, $2); }
  | Expr ':' Expr { $$ = list($2, $1, $3); }
  | Expr '+' Expr { $$ = list($2, $1, $3); }
  | Expr '-' Expr { $$ = list($2, $1, $3); }
  | Expr '*' Expr { $$ = list($2, $1, $3); }
  | Expr '/' Expr { $$ = list($2, $1, $3); }
  | Expr '%' Expr { $$ = list($2, $1, $3); }
  | Expr EQ Expr { $$ = list($2, $1, $3); }
  | Expr NE Expr { $$ = list($2, $1, $3); }
  | Expr GT Expr { $$ = list($2, $1, $3); }
  | Expr LT Expr { $$ = list($2, $1, $3); }
  | Expr GE Expr { $$ = list($2, $1, $3); }
  | Expr LE Expr { $$ = list($2, $1, $3); }
  | Expr AND Expr { const value op = "and"; bindloc(op, @$); $$ = list(op, list("bool", $1), list("bool", $3)); }
  | Expr OR Expr { const value op = "or"; bindloc(op, @$); $$ = list(op, list("bool", $1), list("bool", $3)); }
  | NOT Expr { $$ = list("not", list("bool", $2)); bindloc(car($$), @1); }
  | Lambda
  | If
  | Match
  | LET ListOfBinds IN Expr {
    bool usevalues = false;
    stl::vector<opi::value> letbinds;
    for (const value bind : range($2))
    {
      assert(length(car(bind)) >= 1);
      if (length(car(bind)) > 1)
        usevalues = true;
      letbinds.push_back(cons(car(car(bind)), cdr(bind)));
    }
    if (usevalues)
      $$ = list("let-values", $2, $4);
    else
      $$ = list("let", list(letbinds), $4);
  }
  | LETREC ListOfBinds IN Expr {
    bool usevalues = false;
    stl::vector<opi::value> letbinds;
    for (const value bind : range($2))
    {
      assert(length(car(bind)) >= 1);
      if (length(car(bind)) > 1)
        usevalues = true;
      letbinds.push_back(cons(car(car(bind)), cdr(bind)));
    }
    if (usevalues)
      throw opi::bad_code {"Invalid use of multiple-bindings with letrec-syntax",
                           opi::osl::make_location(@2)};
    else
      $$ = list("letrec", list(letbinds), $4);
  }
  | Expr WHERE ListOfBinds {
    bool usevalues = false;
    stl::vector<opi::value> letbinds;
    for (const value bind : range($3))
    {
      assert(length(car(bind)) >= 1);
      if (length(car(bind)) > 1)
        usevalues = true;
      letbinds.push_back(cons(car(car(bind)), cdr(bind)));
    }
    if (usevalues)
      throw opi::bad_code {"Invalid use of multiple-bindings with where-syntax",
                           opi::osl::make_location(@3)};
    else
      $$ = list("letrec", list(letbinds), $1);
  }
  | ASSERT '{' SeqOfStmts '}' {
    $$ = list("if", False, cons("begin", $3));
  }
  | ASSERT NOT '{' SeqOfStmts '}' {
    const value lambda = list("lambda", nil, dot, $4);
    const value assertion = list("assert_thunk", lambda);
    $$ = list("annotate-type", assertion, "assertion_failure");
  }
;

Stmt
  : STMT
  | Expr
  | Expr '=' Expr {
    if (issym($1))
    { // define variable
      const value define = "define";
      bindloc(define, @$);
      $$ = list(define, $1, $3);
    }
    else if (ispair($1) and car($1) == "annotate-type")
    { // move annotation to the LHS and use `define`-syntax
      const value define = "define";
      bindloc(define, @$);
      const value ident = list_ref($1, 1);
      const value type = list_ref($1, 2);
      const value expr = $3;
      assert(issym(ident));
      $$ = list(define, ident, list("annotate-type", expr, type));
    }
    else
    {
      const value define = "define-overload";
      const value fixed_signature =
          cons(car($1), fix_type_annotations_in_arguments(cdr($1)));
      bindloc(define, @$);
      if (opi::ispair($3) and car($3) == "begin")
      {
        const value body = make_body_with_return(cdr($3));
        $$ = list(define, fixed_signature, dot, body);
      }
      else
      {
        $$ = list(define, fixed_signature, $3);
      }
    }
  }
  | Expr ',' ListOfExprs '=' Expr {
    const value idents = cons($1, $3);
    const value define = "define-values";
    bindloc(define, @$);
    $$ = list(define, idents, $5);
  }
  | EXTERN IDENT DOUBLE_COLUMN AtomTypeParam {
    $$ =
      list("define", $2,
        list("annotate-type", list("pragma", "inline-scheme", $2), $4));
  }
  | EXTERN IDENT AS IDENT DOUBLE_COLUMN AtomTypeParam {
    $$ =
      list("define", $4,
        list("annotate-type", list("pragma", "inline-scheme", $2), $6));
  }
  | EXTERN IDENT '(' ListOfTypeParams ')' RIGHT_ARROW ListOfTypeParams {
    stl::vector<value> wrapperargs, argnames;
    for (const value argtype : range($4))
    {
      const value argname = sym(std::format("x{}", g_counter++));
      argnames.push_back(argname);
      wrapperargs.push_back(list(argname, argtype));
    }
    $$ =
      list("define-overload", cons($2, list(wrapperargs)),
        list(
          list("annotate-type",
            list("pragma", "inline-scheme", $2),
            list("fn", $4, dot, $7)),
          dot, list(argnames)));
  }
  | EXTERN IDENT AS IDENT '(' ListOfTypeParams ')' RIGHT_ARROW ListOfTypeParams {
    stl::vector<value> wrapperargs, argnames;
    for (const value argtype : range($6))
    {
      const value argname = sym(std::format("x{}", g_counter++));
      argnames.push_back(argname);
      wrapperargs.push_back(list(argname, argtype));
    }
    $$ =
      list("define-overload", cons($4, list(wrapperargs)),
        list(
          list("annotate-type",
            list("pragma", "inline-scheme", $2),
            list("fn", $6, dot, $9)),
          dot, list(argnames)));
  }
  | EXTERN FOREIGN IDENT AS IDENT '(' ListOfForeignTypes ')' RIGHT_ARROW ForeignType {
    // TODO: bind locations
    const opi::value chickenrettype = list_ref($10, 0);
    const opi::value oslrettype = list_ref($10, 1);
    opi::value chickentypes, osltypes;
    opi::value argnames = nil;
    opi::value oslargs = nil;
    for (const opi::value t : range($7))
    {
      const opi::value argname = sym(std::format("x{}", g_counter++));
      const value chickentype = list_ref(t, 0);
      const value osltype = list_ref(t, 1);
      append_mut(chickentypes, list(chickentype));
      append_mut(osltypes, list(osltype));
      append_mut(argnames, list(argname));
      append_mut(oslargs, list(list(argname, osltype)));
    }

    const opi::value foreign_safe_lambda =
      list("foreign-safe-lambda", chickenrettype, $3, opi::dot, chickentypes);
    const opi::value foreign_call =
      list(
        list("annotate-type",
          list("pragma", "inline-scheme", foreign_safe_lambda),
          list("fn", osltypes, oslrettype)),
        dot, argnames);
    $$ = list("define-overload", cons($5, oslargs), foreign_call);
  }
  | EXTERN FOREIGN IDENT '(' ListOfForeignTypes ')' RIGHT_ARROW ForeignType {
    // See above but no aliasing
    // TODO: bind locations
    const opi::value chickenrettype = list_ref($8, 0);
    const opi::value oslrettype = list_ref($8, 1);
    opi::value chickentypes, osltypes;
    opi::value argnames = nil;
    opi::value oslargs = nil;
    for (const opi::value t : range($5))
    {
      const opi::value argname = sym(std::format("x{}", g_counter++));
      const value chickentype = list_ref(t, 0);
      const value osltype = list_ref(t, 1);
      append_mut(chickentypes, list(chickentype));
      append_mut(osltypes, list(osltype));
      append_mut(argnames, list(argname));
      append_mut(oslargs, list(list(argname, osltype)));
    }

    const opi::value foreign_safe_lambda =
      list("foreign-safe-lambda", chickenrettype, $3, opi::dot, chickentypes);
    const opi::value foreign_call =
      list(
        list("annotate-type",
          list("pragma", "inline-scheme", foreign_safe_lambda),
          list("fn", osltypes, oslrettype)),
        dot, argnames);
    $$ = list("define-overload", cons($3, oslargs), foreign_call);
  }
;

Lambda
  : '(' ListOfArgs ')' FAT_RIGHT_ARROW Expr { $$ = list("lambda", $2, $5); }
  | IDENT FAT_RIGHT_ARROW Expr { $$ = list("lambda", list($1), $3); }
  | '_' FAT_RIGHT_ARROW Expr { $$ = list("lambda", list("_"), $3); }
;

If
  : IF Expr THEN Expr ELSE Expr { $$ = list("if", list("bool", $2), $4, $6); }
  | IF Expr THEN Expr { $$ = list("if", list("bool", $2), $4, list("osl#null")); }
;

Match
  : MATCH ListOfExprs IN MatchClauses {
    // Fix otherwize-clause
    value newclauses = nil;
    const size_t ncols = length($2);
    for (const value clause : range($4))
    {
      if (car(car(clause)) == "otherwize")
      {
        const auto makewild = []() { return sym("_"); };
        opi::stl::vector<value> newpat;
        std::ranges::generate_n(std::back_inserter(newpat), ncols, makewild);
        const value newclause = cons(list(newpat), cdr(clause));
        newclauses = append(newclauses, list(newclause));
      }
      else
        newclauses = append(newclauses, list(clause));
    }
    bindloc(newclauses, @4);
    const value cases = "cases";
    bindloc(cases, @1);
    $$ = list(cases, $2, dot, newclauses);
  }
;

SeqOfStmts
  : { $$ = nil; }
  | Stmt SeqOfStmts %prec AFTER_APPLY { $$ = cons($1, $2); }
;

TopLvlSeq
  : { $$ = nil; }
  | TopLvlExpr TopLvlSeq %prec AFTER_APPLY { $$ = append($1, $2); }
;

TopLvlExpr
  : Stmt { $$ = list($1); }
  | TypeDef
  | REQUIRE String {
    assert(str_view($2).starts_with("s:"));
    std::filesystem::path filename {str_view($2).data() + 2};
    if (filename.extension() == "")
      filename += ".osl";

    std::filesystem::path fullpath;
    try {
      fullpath = resolve_path(filename, osl::pathes.begin(), osl::pathes.end());
    }
    catch (const std::runtime_error &exn)
    { throw opi::bad_code {exn.what(), opi::osl::make_location(@$)}; }

    if (not g_current_program_parser->target().contains(fullpath))
      g_current_program_parser->load_file(fullpath);

    $$ = nil;
  }
  | FOREIGN_INLINE_BEGIN StringChunks FOREIGN_INLINE_END {
    std::string result;
    result += "\n#>\n";
    for (const value chunk : range($2))
    {
      std::ranges::copy(str_view(chunk), std::back_inserter(result));
      result.push_back('\n');
    }
    result += "<#\n";
    append_mut(g_current_program_parser->m_translator_config.prologue,
               list(sym(result)));
    $$ = nil;
  }
  | SCHEME_INLINE_BEGIN StringChunks SCHEME_INLINE_END {
    std::string text;
    for (const value chunk : range($2))
    {
      std::ranges::copy(str_view(chunk), std::back_inserter(text));
      text.push_back('\n');
    }

    opi::lisp_parser parser;
    try {
      const value schemecode = parser.parse_all(text);
      append_mut(g_current_program_parser->m_translator_config.prologue,
                 schemecode);
    }
    catch (const std::exception &exn)
    {
      opi::error("while parsing inline scheme block: {}\n{}", exn.what(),
                 opi::display_location(osl::make_location(@$)));
      throw;
    }

    $$ = nil;
  }
  | MACRO {
    parse_syntax_cases_macro(*g_current_lexer, *g_current_program_parser);
    $$ = nil;
  }
  | PRAGMA_ IDENT STRING_CHUNK {
    lisp_parser parser;
    assert(isstr($3));
    std::istringstream buf {std::string(str_view($3))};
    const value data = parser.parse_all(buf);
    if ($2 == "prolog")
    {
      for (const value plexpr : range(data))
        g_current_program_parser->m_translator_config.prolog << plexpr;
      $$ = nil;
    }
    else if ($2 == "match-translation-rule")
    {
      value match_pattern;
      value type_pattern;
      value predicate;
      value unpack;
      if (not assoc("match-pattern", data, match_pattern) or
          not assoc("type-pattern", data, type_pattern) or
          not assoc("predicate", data, predicate) or
          not assoc("unpack", data, unpack))
        throw opi::bad_code {"Invalid match-translation-rule",
                             osl::make_location(@$)};
      g_current_program_parser
          ->m_translator_config
          .match_translation
          .add_rule(match_pattern, type_pattern, predicate, unpack);
      $$ = nil;
    }
    else
      $$ = list(list("pragma", $2, dot, data));
  }
;

// TODO: constrain valid type signatures in LHS of type declarations
TypeDef
  : TYPE TypeSign '=' ListOfCtorSigns {
    opi::stl::vector<value> tape;
    source_location location;
    location.source = g_source;
    location.start = @$.left;
    location.end = @$.right;
    generate_variant_type($2, $4, location,
                          g_current_program_parser->m_translator_config,
                          std::back_inserter(tape));
    $$ = list(tape);
    bindloc($$, @$);
  }
  | TYPE TypeSign '=' '{' ListOfFields '}' {
    opi::stl::vector<value> tape;
    
    opi::source_location location;
    location.source = g_source;
    location.start = @$.left;
    location.end = @$.right;

    const auto _car = [](value x) { return car(x); };
    const auto _cadr = [](value x) { return car(cdr(x)); };

    const value type_name = ispair($2) ? car($2) : $2;
    const value scmtypename = opi::sym(std::format("osl#{:r}", type_name));
    const value scmctorname = mangle_type_constructor(type_name);
    const value fieldnames = list(std::views::transform(range($5), _car));
    const value fieldtypes = list(std::views::transform(range($5), _cadr));
    const value scmpredname = opi::sym(std::format("{:r}?", scmtypename));

    assert(issym(type_name));

    const value recorddef =
      generate_record_definition(scmtypename, scmctorname, fieldnames, scmpredname,
                                 g_current_program_parser->m_translator_config);
    generate_record_interface(recorddef, $2, fieldtypes, type_name, location,
                              g_current_program_parser->m_translator_config,
                              std::back_inserter(tape));
    $$ = list(tape);
    bindloc($$, @$);
  }
  | TYPE TypeSign '=' TypeParam {
    const value T = sym("Osl#alias#typevar");
    const value coercefrom = 
      list("predicate", list("coerce", $2, T),
        list("fast-coerce", $4, T));
    const value coerceto =
      list("predicate", list("coerce", T, $2),
        list("fast-coerce", T, $4));
    g_current_program_parser->m_translator_config.prolog << coercefrom;
    g_current_program_parser->m_translator_config.prolog << coerceto;
  }
;

TypeSign
  : IDENT %prec AFTER_APPLY
  | IDENT '(' ListOfTypeParams ')' %prec APPLY { $$ = cons($1, $3); bindloc($$, @$); }
  | FN '(' ListOfTypeParams ')' RIGHT_ARROW AtomTypeParam {
    const value fn = "fn";
    bindloc(fn, @1);
    $$ = list(fn, $3, $6);
  }
  | FN '(' ListOfTypeParams ')' RIGHT_ARROW '(' ListOfTypeParams ')' {
    const value fn = "fn";
    bindloc(fn, @1);
    $$ = list(fn, $3, dot, $7);
  }
;

ListOfCtorSigns: CtorSign '|' ListOfCtorSigns_ { $$ = cons($1, $3); };

ListOfCtorSigns_
  : CtorSign { $$ = list($1); }
  | CtorSign '|' ListOfCtorSigns_ { $$ = cons($1, $3); }
;


CtorSign
  : CAPIDENT '(' ListOfTypeParams ')' %prec APPLY { $$ = cons($1, $3); }
  | CAPIDENT %prec AFTER_APPLY { $$ = list($1); }
;

ListOfTypeParams
  : { $$ = nil; }
  | TypeParam { $$ = list($1); }
  | TypeParam ',' ListOfTypeParams { $$ = cons($1, $3); }
;

AtomTypeParam
  : ATTYPE
  | CAPIDENT
  | '_'
  | TypeSign
  | AtomTypeParam '?' { $$ = list($2, $1); }
  | NOT AtomTypeParam { $$ = list("not", $2); }
  | '(' TypeParam ')' { $$ = $2; }
;

TypeParam
  : EXTYPE
  | AtomTypeParam
  | '=' TypeParam { $$ = list($1, $2); }
  | TypeParam OR TypeParam { $$ = list("or", $1, $3); }
  | TypeParam AND TypeParam { $$ = list("and", $1, $3); }
;

ListOfFields
  : { $$ = nil; }
  | IDENT TypeParam { $$ = list(list($1, $2)); }
  | IDENT TypeParam ',' ListOfFields { $$ = cons(list($1, $2), $4); }
;

ListOfExprs
  : { $$ = nil; }
  | Expr { $$ = list($1); }
  | Expr ',' ListOfExprs { $$ = cons($1, $3); }
;

ListOfArgs
  : { $$ = nil; }
  | ExprWithOptTypeParam { $$ = list($1); }
  | ExprWithOptTypeParam ',' ListOfArgs { $$ = cons($1, $3); }
;

NonZeroListOfIdents
  : IDENT { $$ = list($1); }
  | IDENT ',' NonZeroListOfIdents { $$ = cons($1, $3); }
;

ExprWithOptTypeParam
  : Expr
  | Expr TypeParam { $$ = list($1, $2); }
;


MatchClauses
  : '|' MatchClauses_ { $$ = $2; }
  | MatchClauses_
;

MatchClauses_
  : MatchClause { $$ = list($1); }
  | MatchClause '|' MatchClauses_ { $$ = cons($1, $3); }
;

MatchClause
  : ListOfExprPatterns RIGHT_ARROW Expr { $$ = cons($1, list($3)); }
  | OTHERWIZE RIGHT_ARROW Expr { $$ = cons(list("otherwize"), list($3)); }
;

ListOfExprPatterns
  : { $$ = nil; }
  | ExprPattern { $$ = list($1); }
  | ExprPattern ',' ListOfExprPatterns { $$ = cons($1, $3); }
;

ExprPattern
  : EXPAT
  | AtomPattern
  | ExprPattern ':' ExprPattern {
    const value Cons = mangle_type_constructor("Cons");
    bindloc(Cons, @2);
    $$ = list(Cons, $1, $3);
  }
;

AtomPattern
  : ATPAT
  | IDENT
  | '_' { $$ = $1; }
  | '(' ExprPattern ')' { $$ = $2; }
  // Typename patterns
  | IDENT IDENT { $$ = list(list("typename", $1), $2); }
  | IDENT '(' ListOfTypeParams ')' IDENT { $$ = list(list("typename", cons($1, $3)), $5); }
  | TYPE TypeParam IDENT { $$ = list(list("typename", $2), $3); }
  // Constructor patterns
  | CAPIDENT %prec AFTER_APPLY { $$ = list(mangle_type_constructor($1)); }
  | CAPIDENT '(' ListOfExprPatterns ')' %prec APPLY { $$ = cons(mangle_type_constructor($1), $3); }
  | '[' ']' { $$ = list("osl#ctor#EmptyList"); bindloc($$, @$); }
;


ListOfBinds
  : Bind { $$ = list($1); }
  | Bind ',' ListOfBinds { $$ = cons($1, $3); }
;

Bind
  /*: IDENT '=' Expr { $$ = list($1, $3); }*/
  : NonZeroListOfIdents '=' Expr { $$ = list($1, $3); }
  | IDENT '(' ListOfExprs ')' '=' Expr {
    const value lambda = "lambda";
    bindloc(lambda, @$);
    value lambdaexpr;
    if (ispair($6) and car($6) == "begin")
    {
      const value body = make_body_with_return(cdr($6));
      lambdaexpr = list(lambda, $3, dot, body);
    }
    else
      lambdaexpr = list(lambda, $3, $6);
    $$ = list(list($1), lambdaexpr);
  }
;

ForeignType
  : IDENT { $$ = foreign_type_info($1); }
  | IDENT '*' { $$ = foreign_pointer_type_info($1); }
  | IDENT '[' ']' { $$ = foreign_array_type_info($1); }
  | IDENT '*' '*' { $$ = foreign_pointerpointer_type_info($1); }
;

ListOfForeignTypes
  : { $$ = opi::nil; }
  | ForeignType { $$ = list($1); }
  | ForeignType ',' ListOfForeignTypes { $$ = cons($1, $3); }
;

%%

typedef void* yyscan_t;

extern int
yylex_init(yyscan_t *scanner);

extern void
yyset_in(FILE *in, yyscan_t scanner);

extern void
yylex_destroy(yyscan_t scanner);


static void
bindloc(opi::value val, const range_location &loc)
{
  opi::source_location location;
  location.source = g_source;
  location.start = loc.left;
  location.end = loc.right;
  opi::set_location(val, location);
}

opi::source_location
opi::osl::make_location(const range_location &loc)
{
  opi::source_location location;
  location.source = g_source;
  location.start = loc.left;
  location.end = loc.right;
  return location;
}

namespace opi::osl {

opi::value
opi::osl::parser::parse(int entry_token, generic_lexer &lexer, bool force)
{
  opi::utl::state_saver _ {g_result_ptr, g_current_lexer};

  opi::value result = nil;
  g_result_ptr = &result;

  g_current_lexer = &lexer;

  int status;
  bool enforced = false;
  yypstate *ps = yypstate_new();
  lexer.put(entry_token);
  do {
L_read_next:
    // Read next token
    lexer::token token;
    lexer.read(token);

    // Handle macros
    auto [begin, end] = m_macros.equal_range({token.type, token.value});
    for (const auto &[_, macro] : std::ranges::subrange(begin, end))
    {
      for (const macro_case &mcase : macro)
      {
        opi::stl::unordered_map<opi::value, opi::value> paramvals;

        // Put the macro-trigger token back and run the macro
        stateful_lexer stlexer {lexer};
        stateful_lexer::state lexst = stlexer.current_state();
        try
        {
          debug("testing macro {}", token.value);
          stlexer.put(token);
          macro_pattern_matcher(mcase.paramtypes, paramvals)
            .match_syntax(stlexer, *this, mcase.pattern);
          macro_expander(mcase.paramtypes, paramvals)
            .expand(stlexer, mcase.rule);
          debug("successfuly aplied macro {}", token.value);
          goto L_read_next;
        }
        catch (const parse_error&)
        {
          debug("recovering lexer state after failed attempt to use macro {}",
                token.value);
          stlexer.recover_state(lexst);
          lexer::token nexttoken;
          lexer.peek(nexttoken);
          debug("next token: {}", nexttoken.value);
        }
      }
    }

    // Convert token into bison's representatoin
    value yylval = token.value;
    range_location yyloc {token.location.start, token.location.end};

    try {
      // Run one parser iteration
      status = yypush_parse(ps, token.type, &yylval, &yyloc, nullptr);
    }
    catch (const parse_error&) {
      if (force and not enforced)
      { // Put back the last token weve read and inject and EOF to force parser
        // to finish
        lexer.put(token);
        lexer.put(YYEOF);
        enforced = true;
        continue;
      }
      else
        throw;
    }
  } while (status == YYPUSH_MORE);
  yypstate_delete(ps);

  return result;
}


void
program_parser::load_source(const std::string &source, std::FILE *file)
{
  opi::utl::state_saver _ {g_source, g_current_program_parser};
  g_source = source;
  g_current_program_parser = this;

  lexer scanner {{source, 0, 0}, file};
  const opi::value result = parse(PARSE_TOPLVL, scanner);
  m_target.append(source, result);
}

} // namespace opi::osl
