// TODO: refactor

require "base"
require "error"

~~~
(import hash-trie)
~~~

extern identifier!(hash-trie/insert) as insert(explicit trie(K, V), K, V) -> trie(K, V)
extern identifier!(hash-trie/delete) as remove(explicit trie(K, V), K) -> trie(K, V)
extern identifier!(hash-trie/lookup) as get(explicit trie(K, V), K, V) -> V
extern identifier!(hash-trie/count) as length(explicit trie(K, V)) -> num
extern identifier!(hash-trie/empty?) as empty(explicit trie(K, V)) -> num
extern identifier!(hash-trie/member?) as contains(explicit trie(K, V), K) -> bool


trie() = {
  extern identifier!(make-hash-trie)(trietype(K, V)) -> trie(K, V)
  extern identifier!(make-hash-trie-type)(fn(K, K) -> bool, fn(K) -> num) -> trietype(K, V)

  equalfn = (==) as fn(K, K) -> bool
  hashfn = hash as fn(K) -> num
  trietype = identifier!(make-hash-trie-type)(equalfn, hashfn)
  return identifier!(make-hash-trie)(trietype)
}

identifier!(osl#ref)(t explicit trie(K, V), key K) = {
  default = scm { (gensym) } :: V
  result = get(t, key, default)
  if (scm { eq? } :: fn(V, V) -> bool) (result, default) then
    error("No such key", key, t)
  return result
}
