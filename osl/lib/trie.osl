// TODO: refactor

require "base"
require "error"

~~~
(import hash-trie)
~~~

extern identifier!(hash-trie/insert) as insert(trie(K, V), K, V) -> trie(K, V)
extern identifier!(hash-trie/delete) as remove(trie(K, V), K) -> trie(K, V)
extern identifier!(hash-trie/lookup) as get(trie(K, V), K, V) -> V
extern identifier!(hash-trie/count) as length(trie(K, V)) -> num
extern identifier!(hash-trie/empty?) as empty(trie(K, V)) -> num
extern identifier!(hash-trie/member?) as contains(trie(K, V), K) -> bool


trie() = {
  extern identifier!(make-hash-trie)(trietype(K, V)) -> trie(K, V)
  extern identifier!(make-hash-trie-type)(fn(K, K) -> bool, fn(K) -> num) -> trietype(K, V)

  equalfn = (==) as fn(K, K) -> bool
  hashfn = hash as fn(K) -> num
  trietype = identifier!(make-hash-trie-type)(equalfn, hashfn)
  return identifier!(make-hash-trie)(trietype)
}

trie::trie(K, V)[key::K] = {
  default = reinterpret_cast(scm { (gensym) }) :: V
  result = get(trie, key, default)
  if reinterpret_cast(scm { eq? }(result, default)) :: bool then
    error("No such key", key, trie)
  return result
}
