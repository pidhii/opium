require "typeutils"

// Foreign types primitives:
// - i8
// - u8
// - i16
// - u16
// - i32
// - u32
// - i64
// - u64
// - f32
// - f54
// - void
// - cstr

sizeof(_ the(i8)) = 1
sizeof(_ the(u8)) = 1
sizeof(_ the(i16)) = 2
sizeof(_ the(u16)) = 2
sizeof(_ the(i32)) = 4
sizeof(_ the(u32)) = 4
sizeof(_ the(i64)) = 8
sizeof(_ the(u64)) = 8
sizeof(_ the(f32)) = 4
sizeof(_ the(f64)) = 8
sizeof(_ the(ptr(_))) = 8 // FIXME (platform dependent)


////////////////////////////////////////////////////////////////////////////////
//                             Locatives
//
#pragma scheme-translator { (inline (import (chicken locative))) }
// TODO
// - I think for a locative of a k-th element of a list we have to first iterate
//   through the list (manualy) to reach the correct pair
// - locatives for records

extern identifier!(make-locative) as locationof(array(T), num) -> locative(T, array)
// extern identifier!(make-locative) as locationof(list(T), num) -> locative(T, array)
extern identifier!(make-locative) as locationof(str, num) -> locative(char, ptr(i8))
extern identifier!(make-locative) as locationof(blob, num) -> locative(num, ptr(u8))
extern identifier!(make-locative) as locationof(i8array, num) -> locative(num, ptr(i8))
extern identifier!(make-locative) as locationof(u8array, num) -> locative(num, ptr(u8))
extern identifier!(make-locative) as locationof(i16array, num) -> locative(num, ptr(i16))
extern identifier!(make-locative) as locationof(u16array, num) -> locative(num, ptr(u16))
extern identifier!(make-locative) as locationof(i32array, num) -> locative(num, ptr(i31))
extern identifier!(make-locative) as locationof(u32array, num) -> locative(num, ptr(u32))
extern identifier!(make-locative) as locationof(i64array, num) -> locative(num, ptr(i64))
extern identifier!(make-locative) as locationof(u64array, num) -> locative(num, ptr(u64))
extern identifier!(make-locative) as locationof(f32array, num) -> locative(num, ptr(f32))
extern identifier!(make-locative) as locationof(f64array, num) -> locative(num, ptr(f64))

extern identifier!(make-locative) as (&) (array(T)) -> locative(T, array)
extern identifier!(make-locative) as (&) (list(T)) -> locative(T, array)
extern identifier!(make-locative) as (&) (str) -> locative(char, ptr(i8))
extern identifier!(make-locative) as (&) (blob) -> locative(num, ptr(u8))
extern identifier!(make-locative) as (&) (i8array) -> locative(num, ptr(i8))
extern identifier!(make-locative) as (&) (u8array) -> locative(num, ptr(u8))
extern identifier!(make-locative) as (&) (i16array) -> locative(num, ptr(i16))
extern identifier!(make-locative) as (&) (u16array) -> locative(num, ptr(u16))
extern identifier!(make-locative) as (&) (i32array) -> locative(num, ptr(i32))
extern identifier!(make-locative) as (&) (u32array) -> locative(num, ptr(u32))
extern identifier!(make-locative) as (&) (i64array) -> locative(num, ptr(i64))
extern identifier!(make-locative) as (&) (u64array) -> locative(num, ptr(u64))
extern identifier!(make-locative) as (&) (f32array) -> locative(num, ptr(f32))
extern identifier!(make-locative) as (&) (f64array) -> locative(num, ptr(f64))

extern identifier!(locative-ref) as (*) (locative(T, _)) -> T
extern identifier!(locative-set!) as identifier!(osl#store)(locative(T, _), T) -> void

ptr(l locative(_, ptr(D))) = reinterpret_cast(l) :: ptr(D)

////////////////////////////////////////////////////////////////////////////////
//                             Pointers
//
#pragma scheme-translator { (inline (import (chicken memory))) }

extern identifier!(pointer->address) as num(ptr(_)) -> num
extern identifier!(pointer->address) as num(locative(_, _)) -> num

extern identifier!(pointer+)(ptr(T), num) -> ptr(T)
p::ptr(T) + n::num = identifier!(pointer+)(p, n * sizeof(the() :: the(T)))
p::ptr(T) - n::num = identifier!(pointer+)(p, (0-n) * sizeof(the() :: the(T)))

extern identifier!(pointer-s8-set!)  as identifier!(osl#store)(ptr(i8), num) -> void
extern identifier!(pointer-u8-set!)  as identifier!(osl#store)(ptr(u8), num) -> void
extern identifier!(pointer-s16-set!) as identifier!(osl#store)(ptr(i16), num) -> void
extern identifier!(pointer-u16-set!) as identifier!(osl#store)(ptr(u16), num) -> void
extern identifier!(pointer-s32-set!) as identifier!(osl#store)(ptr(i32), num) -> void
extern identifier!(pointer-u32-set!) as identifier!(osl#store)(ptr(u32), num) -> void
extern identifier!(pointer-s64-set!) as identifier!(osl#store)(ptr(i64), num) -> void
extern identifier!(pointer-u64-set!) as identifier!(osl#store)(ptr(u64), num) -> void
extern identifier!(pointer-f32-set!) as identifier!(osl#store)(ptr(f32), num) -> void
extern identifier!(pointer-f64-set!) as identifier!(osl#store)(ptr(f64), num) -> void
extern identifier!(pointer-u64-set!)(ptr(ptr(_)), num) -> void
set *p::ptr(ptr(T)) = v::ptr(T) = identifier!(pointer-u64-set!)(p, num(v))
set p::ptr(T)[k::num] = v = set *(p + k) =  v

extern allocate(num) -> ptr(_)
extern free(ptr(_)) -> void

// Data layout compatability rules
extern bloblike(blob) -> t
extern bloblike(str) -> t
extern bloblike(i8array) -> t
extern bloblike(u8array) -> t
extern bloblike(i16array) -> t
extern bloblike(u16array) -> t
extern bloblike(i32array) -> t
extern bloblike(u32array) -> t
extern bloblike(i64array) -> t
extern bloblike(u64array) -> t
extern bloblike(f32array) -> t
extern bloblike(f64array) -> t
extern bloblike(ptr(_)) -> t
extern bloblike(locative(_, ptr(_))) -> t

compatible_storage(a locative(_, DataRepr), b locative(_, DataRepr)) = void()
compatible_storage(a, b) = { assert { bloblike(a) bloblike(b) } }

extern identifier!(move-memory!)(Src, Dst) -> void
extern identifier!(move-memory!)(Src, Dst, num) -> void
extern identifier!(move-memory!)(Src, Dst, num, num) -> void
extern identifier!(move-memory!)(Src, Dst, num, num, num) -> void

copy(src, dst, bytes num, srcoffs num, dstoffs num) = {
  assert { compatible_storage(src, dst) }
  identifier!(move-memory!)(src, dst, bytes, srcoffs, dstoffs)
}
copy(src, dst, bytes num, srcoffs num) = copy(src, dst, bytes, srcoffs, 0)
copy(src, dst, bytes num) = copy(src, dst, bytes, 0, 0)

strdup(s str) = {
  n = length(s)
  p = allocate(n + 1) :: ptr(i8)
  copy(s, p, n)
  p[n] = 0
  return p
}