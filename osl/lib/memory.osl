require "typeutils"


// Foreign types primitives:
// - i8
// - u8
// - i16
// - u16
// - i32
// - u32
// - i64
// - u64
// - f32
// - f54
// - void
// - cstr

sizeof(_ the(i8)) = 1
sizeof(_ the(u8)) = 1
sizeof(_ the(i16)) = 2
sizeof(_ the(u16)) = 2
sizeof(_ the(i32)) = 4
sizeof(_ the(u32)) = 4
sizeof(_ the(i64)) = 8
sizeof(_ the(u64)) = 8
sizeof(_ the(f32)) = 4
sizeof(_ the(f64)) = 8
sizeof(_ the(ptr(_))) = 8 // FIXME (platform dependent)


////////////////////////////////////////////////////////////////////////////////
//                             Locatives
//
~~~
(import (chicken locative))
~~~
// NOTE: Purposefuly omiting locatives for pairs (lists) as implementation will
// be rather sketchy and their potential use cases appear to me being very
// questionable

extern identifier!(make-locative) as locationof(array(T), num) -> locative(T, array(T))
extern identifier!(make-locative) as locationof(str, num) -> locative(char, ptr(i8))
extern identifier!(make-locative) as locationof(blob, num) -> locative(num, ptr(u8))
extern identifier!(make-locative) as locationof(i8array, num) -> locative(num, ptr(i8))
extern identifier!(make-locative) as locationof(u8array, num) -> locative(num, ptr(u8))
extern identifier!(make-locative) as locationof(i16array, num) -> locative(num, ptr(i16))
extern identifier!(make-locative) as locationof(u16array, num) -> locative(num, ptr(u16))
extern identifier!(make-locative) as locationof(i32array, num) -> locative(num, ptr(i31))
extern identifier!(make-locative) as locationof(u32array, num) -> locative(num, ptr(u32))
extern identifier!(make-locative) as locationof(i64array, num) -> locative(num, ptr(i64))
extern identifier!(make-locative) as locationof(u64array, num) -> locative(num, ptr(u64))
extern identifier!(make-locative) as locationof(f32array, num) -> locative(num, ptr(f32))
extern identifier!(make-locative) as locationof(f64array, num) -> locative(num, ptr(f64))

extern identifier!(make-locative) as (&) (array(T)) -> locative(T, array(T))
extern identifier!(make-locative) as (&) (str) -> locative(char, ptr(i8))
extern identifier!(make-locative) as (&) (blob) -> locative(num, ptr(u8))
extern identifier!(make-locative) as (&) (i8array) -> locative(num, ptr(i8))
extern identifier!(make-locative) as (&) (u8array) -> locative(num, ptr(u8))
extern identifier!(make-locative) as (&) (i16array) -> locative(num, ptr(i16))
extern identifier!(make-locative) as (&) (u16array) -> locative(num, ptr(u16))
extern identifier!(make-locative) as (&) (i32array) -> locative(num, ptr(i32))
extern identifier!(make-locative) as (&) (u32array) -> locative(num, ptr(u32))
extern identifier!(make-locative) as (&) (i64array) -> locative(num, ptr(i64))
extern identifier!(make-locative) as (&) (u64array) -> locative(num, ptr(u64))
extern identifier!(make-locative) as (&) (f32array) -> locative(num, ptr(f32))
extern identifier!(make-locative) as (&) (f64array) -> locative(num, ptr(f64))

extern identifier!(locative-ref) as (*) (locative(T, _)) -> T
extern identifier!(locative-set!) as identifier!(osl#store)(locative(T, _), T) -> void


////////////////////////////////////////////////////////////////////////////////
//                             Pointers
//
~~~
(import (chicken memory))
~~~

// TODO:
// In some occasions it is possible to pass an apropriate locative in place of a
// pointer (e.g. as argument to a foreign function). However this is not a
// universal thing, and so arbitrary `reinterpret_cast` of a locative into
// pointer is wrong. Cases where both locative and pointer are acceptable has to
// be handled via coercion.
// ptr(l locative(_, ptr(D))) = reinterpret_cast(l) :: ptr(D)

extern identifier!(address->pointer) as ptr(num) -> ptr(_)

extern identifier!(pointer-s8-set!)  as identifier!(osl#store)(ptr(i8), num) -> void
extern identifier!(pointer-u8-set!)  as identifier!(osl#store)(ptr(u8), num) -> void
extern identifier!(pointer-s16-set!) as identifier!(osl#store)(ptr(i16), num) -> void
extern identifier!(pointer-u16-set!) as identifier!(osl#store)(ptr(u16), num) -> void
extern identifier!(pointer-s32-set!) as identifier!(osl#store)(ptr(i32), num) -> void
extern identifier!(pointer-u32-set!) as identifier!(osl#store)(ptr(u32), num) -> void
extern identifier!(pointer-s64-set!) as identifier!(osl#store)(ptr(i64), num) -> void
extern identifier!(pointer-u64-set!) as identifier!(osl#store)(ptr(u64), num) -> void
extern identifier!(pointer-f32-set!) as identifier!(osl#store)(ptr(f32), num) -> void
extern identifier!(pointer-f64-set!) as identifier!(osl#store)(ptr(f64), num) -> void
extern identifier!(pointer-u64-set!)(ptr(ptr(_)), num) -> void // FIXME (platform dependent)
set *p::ptr(ptr(T)) = v::ptr(T) = identifier!(pointer-u64-set!)(p, num(v))
set p::ptr(_)[k::num] = v = set *(p + k) =  v


extern identifier!(pointer-s8-ref)  as (*) (ptr(i8)) -> num
extern identifier!(pointer-u8-ref)  as (*) (ptr(u8)) -> num
extern identifier!(pointer-s16-ref) as (*) (ptr(i16)) -> num
extern identifier!(pointer-u16-ref) as (*) (ptr(u16)) -> num
extern identifier!(pointer-s32-ref) as (*) (ptr(i32)) -> num
extern identifier!(pointer-u32-ref) as (*) (ptr(u32)) -> num
extern identifier!(pointer-s64-ref) as (*) (ptr(i64)) -> num
extern identifier!(pointer-u64-ref) as (*) (ptr(u64)) -> num
extern identifier!(pointer-f32-ref) as (*) (ptr(f32)) -> num
extern identifier!(pointer-f64-ref) as (*) (ptr(f64)) -> num
// FIXME (platform dependent)
(*)(p ptr(ptr(T))) = ptr(*(reinterpret_cast(p) :: ptr(u64))) :: ptr(T)
p::ptr(T)[k::num] = *(p + k)

extern identifier!(pointer?) as bool(ptr(_)) -> bool
nullptr() = reinterpret_cast(false) :: ptr(_)


////////////////////////////////////////////////////////////////////////////////
//                  Common interface mixing pointers and locatives
#pragma prolog {
  (predicate (coerce (ptr T) (pointerlike (ptr T))))
  (predicate (coerce (locative _ Layout) (pointerlike Layout)))
}
extern identifier!(pointer=?) as (==) (pointerlike(L), pointerlike(L)) -> bool
extern identifier!(pointer->address) as num(pointerlike(_)) -> num

extern identifier!(pointer+)(ptr(T), num) -> ptr(T)
p::ptr(T) + n::num = identifier!(pointer+)(p, n * sizeof(the() :: the(T)))
p::ptr(T) - n::num = identifier!(pointer+)(p, -n * sizeof(the() :: the(T)))
p::locative(_, array(_)) + n::num = identifier!(pointer+)(p, n * 8) // FIXME (platform dependent)
p::locative(_, array(_)) - n::num = identifier!(pointer+)(p, -n * 8) // FIXME (platform dependent)
p::locative(_, ptr(T)) + n::num = identifier!(pointer+)(p, n * sizeof(the() :: the(T)))
p::locative(_, ptr(T)) - n::num = identifier!(pointer+)(p, -n * sizeof(the() :: the(T)))


////////////////////////////////////////////////////////////////////////////////
//                            Memory operations
//
extern allocate(num) -> ptr(_)
extern free(ptr(_)) -> void

// Data layout compatability rules
bloblike(_ blob or str or i8array or u8array or i16array or u16array or
           i32array or u32array or i64array or u64array or f32array or
           f64array or ptr(_) or locative(_, ptr(_)))
  = { }

compatible_storage(a locative(_, Layout), b locative(_, Layout)) = { }
compatible_storage(a A, b B) = { assert { bloblike(a) bloblike(b) } }

copy(src, dst, bytes num, srcoffs num, dstoffs num) = {
  extern identifier!(move-memory!)(Src, Dst, num, num, num) -> void
  assert { compatible_storage(src, dst) }
  identifier!(move-memory!)(src, dst, bytes, srcoffs, dstoffs)
}
copy(src, dst, bytes num, srcoffs num) = copy(src, dst, bytes, srcoffs, 0)
copy(src, dst, bytes num) = copy(src, dst, bytes, 0, 0)
copy(src, dst) = {
  extern identifier!(move-memory!)(Src, Dst) -> void
  assert { compatible_storage(src, dst) length(src) length(dst) }
  identifier!(move-memory!)(src, dst)
}

strdup(s str) = {
  n = length(s)
  p = allocate(n + 1) :: ptr(i8)
  copy(s, p, n)
  p[n] = 0
  return p
}
