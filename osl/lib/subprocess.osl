// TODO: refactor

require "base"


// Interface to the child process
type process = {
  stdout port,
  stderr port,
  stdin port,
  pid num,
}

~~~
(import (chicken process))

(define (osl_process cmd #!optional (args #f))
  (cond
    (args
      (let-values (((pstdout pstdin pid pstderr) (process* cmd args)))
        (osl#ctor#process pstdout pstderr pstdin pid)))
    (else
      (let-values (((pstdout pstdin pid pstderr) (process* cmd)))
        (osl#ctor#process pstdout pstderr pstdin pid)))))

(define osl_process_sleep process-sleep)
~~~

#pragma prolog {
  (predicate (result-of (osl_process . Args) process)
    (or (= Args (str))
        (= Args (str (list str)))))

  (predicate (result-of (osl_process_sleep num) num))

  (predicate (result-of (system str) num))

  (predicate (result-of (exit num) _))
}

// system(COMMANDLINE) -> num
//
// Execute shell command. The functionality offered by this procedure depends on
// the capabilities of the host shell. If the forking of a subprocess failed, an
// exception is raised. Otherwise the return status of the subprocess is
// returned unaltered.

// run(COMMANDLINE) -> process
// Passes COMMANDLINE to the host-system's shell that is invoked as a subprocess
//
// run(COMMAND, ARGUMENT-LIST) -> process
// Invokes the COMMAND as a subprocess passing ARGUMENT-LIST as arguments
//
// Create a subprocess
run = osl_process

// wait() -> PID, EXITED, STATUS
// wait(PID) -> PID, EXITED, STATUS
// wait(PID, NOHANG) -> PID, EXITED, STATUS
//
// where
// o PID    - PID or 0, if NOHANG is true and the child process has not
//            terminated yet
// o EXITED - True if the process exited normally or false otherwise
// o STATUS - Either the exit status, if the process terminated normally or
//            the signal number that terminated/stopped the process.
//
// Suspends the current process until the child process with the id PID has
// terminated using the UNIX system call waitpid(). If PID is not given, then
// this procedure waits for any child process. If NOHANG is given and not false
// then the current process is not suspended.
extern identifier!(process-wait) as wait() -> num, bool, num
extern identifier!(process-wait) as wait(num) -> num, bool, num
extern identifier!(process-wait) as wait(num, bool) -> num, bool, num

// wait(PROCESS) -> PID, EXITED, STATUS
// wait(PROCESS, NOHANG) -> PID, EXITED, STATUS
//
// Same as above but accept process object in place of the PID argument
wait(p process) = wait(p#pid)
wait(p process, nohang bool) = wait(p#pid, nohang)

// sleep(SECONDS) -> num
//
// Puts the process to sleep for SECONDS. Returns either 0 if the time has
// completely elapsed, or the number of remaining seconds, if a signal occurred.
sleep = osl_process_sleep
