// TODO: refactor

require "base"


// Interface to the child process
type process = {
  out port,
  err port,
  stdin port,
  pid num,
}

~~~
(import (chicken process))

(define (osl#process cmd #!optional (args #f))
  (cond
    (args
      (let-values (((pstdout pstdin pid pstderr) (process* cmd args)))
        (osl#ctor#process pstdout pstderr pstdin pid)))
    (else
      (let-values (((pstdout pstdin pid pstderr) (process* cmd)))
        (osl#ctor#process pstdout pstderr pstdin pid)))))
~~~

extern exit(num) -> _

// system(COMMANDLINE) -> num
//
// Execute shell command. The functionality offered by this procedure depends on
// the capabilities of the host shell. If the forking of a subprocess failed, an
// exception is raised. Otherwise the return status of the subprocess is
// returned unaltered.
extern system(str) -> num

// run(COMMANDLINE) -> process
// Passes COMMANDLINE to the host-system's shell that is invoked as a subprocess
//
// run(COMMAND, ARGUMENT-LIST) -> process
// Invokes the COMMAND as a subprocess passing ARGUMENT-LIST as arguments
//
// Create a subprocess
extern identifier!(osl#process) as run(str) -> process
extern identifier!(osl#process) as run(str, list(str)) -> process

// wait() -> PID, EXITED, STATUS
// wait(PID) -> PID, EXITED, STATUS
// wait(PID, NOHANG) -> PID, EXITED, STATUS
//
// where
// o PID    - PID or 0, if NOHANG is true and the child process has not
//            terminated yet
// o EXITED - True if the process exited normally or false otherwise
// o STATUS - Either the exit status, if the process terminated normally or
//            the signal number that terminated/stopped the process.
//
// Suspends the current process until the child process with the id PID has
// terminated using the UNIX system call waitpid(). If PID is not given, then
// this procedure waits for any child process. If NOHANG is given and not false
// then the current process is not suspended.
extern identifier!(process-wait) as wait() -> num, bool, num
extern identifier!(process-wait) as wait(num) -> num, bool, num
extern identifier!(process-wait) as wait(num, bool) -> num, bool, num

// wait(PROCESS) -> PID, EXITED, STATUS
// wait(PROCESS, NOHANG) -> PID, EXITED, STATUS
//
// Same as above but accept process object in place of the PID argument
wait(p process) = wait(p#pid)
wait(p process, nohang bool) = wait(p#pid, nohang)

// sleep(SECONDS) -> num
//
// Puts the process to sleep for SECONDS. Returns either 0 if the time has
// completely elapsed, or the number of remaining seconds, if a signal occurred.
extern identifier!(process-sleep) as sleep(num) -> num
