require "base"

#pragma scheme-translator {
  (inline
    (import zmq)
    (import (chicken blob))
    (import (chicken memory))

    (define zmq_version zmq-version)
    (define (zmq_send_message SOCKET MESSAGE OPTIONS)
      (let ((sndmore (memq (quote sndmore) OPTIONS))
            (dontwait (memq (quote dontwait) OPTIONS)))
        (send-message SOCKET MESSAGE send-more: sndmore non-blocking: dontwait)))

    (define (zmq_default_receive_callback ptr size)
      (let ((result (make-blob size)))
        (move-memory! ptr result size)
        result))

    (define (zmq_receive_message SOCKET OPTIONS)
      (let* ((dontwait (memq (quote dontwait) OPTIONS))
             (message (receive-message SOCKET non-blocking: dontwait as: (quote blob))))
        (if message
          (oslctor:Some message)
          (oslctor:Nothing))))
      
  )
}

#pragma prolog {
  (predicate (result-of (zmq_version) (list num)))
  (predicate (result-of (zmq_send_message zmq_socket MESSAGE (list zmq_send_option)) num)
    (or (= MESSAGE str)
        (= MESSAGE blob)))
  (predicate (result-of (zmq_receive_message zmq_socket (list zmq_send_option)) (maybe blob)))
}

////////////////////////////////////////////////////////////////////////////////
//                              Socket types
pull::zmq_socket_type = reinterpret_cast(sym("pull"))
push::zmq_socket_type = reinterpret_cast(sym("push"))
pair::zmq_socket_type = reinterpret_cast(sym("pair"))
pub::zmq_socket_type = reinterpret_cast(sym("pub"))
sub::zmq_socket_type = reinterpret_cast(sym("sub"))
req::zmq_socket_type = reinterpret_cast(sym("req"))
rep::zmq_socket_type = reinterpret_cast(sym("rep"))
dealer::zmq_socket_type = reinterpret_cast(sym("xreq"))
router::zmq_socket_type = reinterpret_cast(sym("xrep"))

////////////////////////////////////////////////////////////////////////////////
//                             Socket options
//
// SNDHWM - high water mark (integer, maximum number of outstanding messages)
// RCVHWM - high water mark (integer, maximum number of outstanding messages)
// AFFINITY - I/O thread affinity (integer, bitmap)
// IDENTITY - socket identity (string, max. 255 bytes)
// SUBSCRIBE - add message filter (string, message prefix)
// UNSUBSCRIBE - remove message filter (string, message prefix)
// RATE - multicast data rate (integer, kilobits per second)
// RECOVERY-IVL - multicast recovery interval (integer, seconds)
// SNDBUF - kernel transmit buffer size (integer, bytes, 0 for OS default)
// RCVBUF - kernel receive buffer size (integer, bytes, 0 for OS default)
sndhwm = reinterpret_cast(sym("sndhwm")) :: zmq_socket_option(num)
rcvhwm = reinterpret_cast(sym("rcvhwm")) :: zmq_socket_option(num)
affinity = reinterpret_cast(sym("affinity")) :: zmq_socket_option(num)
identity = reinterpret_cast(sym("identity")) :: zmq_socket_option(str)
subscribe = reinterpret_cast(sym("subscribe")) :: zmq_socket_option(str)
unsubscribe = reinterpret_cast(sym("unsubscribe")) :: zmq_socket_option(str)
rate = reinterpret_cast(sym("rate")) :: zmq_socket_option(num)
recovery_ivl = reinterpret_cast(sym("recovery-ivl")) :: zmq_socket_option(num)
sndbuf = reinterpret_cast(sym("sndbuf")) :: zmq_socket_option(num)
rcvbuf = reinterpret_cast(sym("rcvbuf")) :: zmq_socket_option(num)

// SNDMORE
// DONTWAIT
sndmore::zm_send_option = reinterpret_cast(sym("sndmore"))
dontwait::zm_send_option = reinterpret_cast(sym("dontwait"))


////////////////////////////////////////////////////////////////////////////////
//                             Functions
//
// -----------------------------------------------------------------------------
//                              context
// Default context
extern identifier!(zmq-default-context) as zmq_default_context :: parameter(zmq_context)
// Set/get number of IO threads in the default context
extern identifier!(zmq-io-threads) as zmq_io_threads :: parameter(num)

// Create context
extern identifier!(make-context) as zmq_context(num) -> zmq_context

// -----------------------------------------------------------------------------
//                              sockets
// Create socket
extern identifier!(make-socket) as zmq_socket(zmq_socket_type, zmq_context) -> zmq_socket
extern identifier!(make-socket) as zmq_socket(zmq_socket_type) -> zmq_socket
socket(context zmq_context, socktype zmq_socket_type) = zmq_socket(socktype, context)

// Close socket
extern identifier!(close-socket) as close(zmq_socket) -> void

// Bind serving socket to an endpoint
extern identifier!(bind-socket) as bind(zmq_socket, str) -> void

// Connect client socket to an endpoint
extern identifier!(connect-socket) as connect(zmq_socket, str) -> void

// Socket options
extern identifier!(socket-option-set!) as sockopt(zmq_socket, zmq_socket_option(T), T) -> void
extern identifier!(socket-option) as sockopt(zmq_socket, zmq_socket_option(T)) -> T

// Socket I/O
send(sock zmq_socket, msg, opts list(zmq_send_options)) = zmq_send_message(sock, msg, opts)
send(sock zmq_socket, msg) = zmq_send_message(sock, msg, [])
recv(sock zmq_socket, opts list(zmq_send_option)) = zmq_receive_message(sock, opts)
recv(sock zmq_socket) = zmq_receive_message(sock, [])
