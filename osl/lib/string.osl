require "itertools"
require "number"

////
//
// Builtin operations with strings
//
~~~
(import (chicken string) srfi-13)

(define concat string-append)
~~~
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")
  (predicate (result-of (concat . Strs) str) (all str Strs))
}
extern concat :: concat

extern identifier!(list->string) as str(explicit list(char)) -> str
str(iter) = {
  assert { next(iter) }
  list(iter).str()
}

extern identifier!(string-copy) as copy(explicit str) -> str
extern identifier!(string-copy) as copy(explicit str, num, num) -> str

// STRING + STRING -> str
//
// Concatenate strings
s1 + s2 = concat(s1, s2)

// STRING[INDEX] -> char
//
// String element access
substr(s explicit str, start num, end num) = {
  extern substring(str, num, num) -> str

  if start < 0 then
    set start = length(s) + start + 1
  if end < 0 then
    set end = length(s) + end + 1
  return substring(s, start, end)
}
extern identifier!(string-ref) as identifier!(osl#ref)(explicit str, num) -> char
identifier!(osl#ref)(s explicit str, r range(num)) = substr(s, r#start, r#end)
extern identifier!(string-set!) as identifier!(osl#set)(explicit str, num, char) -> void

view(s explicit str, start num, end num) = {
  extern identifier!(substring/shared)(str, num, num) -> str
  let start = if start < 0 then length(s) + start + 1 else start in
  let end = if end < 0 then length(s) + end + 1 else end in
  return identifier!(substring/shared)(s, start, end)
}

// String comparison operators
extern identifier!(string=?) as (==) (explicit str, str) -> bool
(!=) (s1 explicit str, s2 str) = not (s1 == s2)
extern identifier!(string<?) as (<) (explicit str, str) -> bool
extern identifier!(string>?) as (>) (explicit str, str) -> bool
extern identifier!(string<=?) as (<=) (explicit str, str) -> bool
extern identifier!(string>=?) as (>=) (explicit str, str) -> bool

extern identifier!(char=?) as (==) (explicit char, char) -> bool
(!=) (c1 explicit char, c2 char) = not (c1 == c2)
extern identifier!(char<?) as (<) (explicit char, char) -> bool
extern identifier!(char>?) as (>) (explicit char, char) -> bool
extern identifier!(char<=?) as (<=) (explicit char, char) -> bool
extern identifier!(char>=?) as (>=) (explicit char, char) -> bool


// String length
extern identifier!(string-length) as length(explicit str) -> num

// Casts
str(s explicit str) = s
extern identifier!(string->list) as list(explicit str) -> list(char)
num(s explicit str) = {
  extern identifier!(string->number) as str2num(str) -> num?
  return if let n = str2num(s) then *n else 0
}
extern identifier!(integer->char) as char(explicit num) -> char
extern identifier!(char->integer) as num(explicit char) -> num

// If STRING ends with SUFFIX, then this procedure returns a copy of its first
// argument with the suffix removed, otherwise returns STRING unchanged.
// SUFFIX defaults to "\n".
extern identifier!(string-chomp) as chomp(str) -> str
extern identifier!(string-chomp) as chomp(str, str) -> str


// String iterators
type strIterator = { s str, i num }
next(it explicit strIterator) = {
  if it#i < length(it#s) then
  {
    c = it#s[it#i]
    set it#i = it#i + 1
    return Some(c)
  }
  else
    return Nothing
}
iter(s explicit str, from num, to num) = strIterator(view(s, from, to), 0)
iter(s explicit str, from num) = strIterator(s, from)
iter(s explicit str) = strIterator(s, 0)
