require "itertools"
require "error"

////
//
// Builtin operations with strings
//
#pragma scheme-translator {
  (inline
    (import (chicken string))

    (define strcat string-append)

    (define strlen string-length)

    (define streq string=?)
    (define strlt string<?)
    (define strle string<=?)
    (define strgt string>?)
    (define strge string>=?)

    (define strcieq string=?)
    (define strcilt string<?)
    (define strcile string<=?)
    (define strcigt string>?)
    (define strcige string>=?)

    (define str2list string->list)
    (define (str2num STRING)
      (let ((result (string->number STRING)))
        (if result
          (maybe.Some result)
          (maybe.Nothing)))))
}
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Type signatures for the renamed functions
  (predicate (result-of (strcat . Strs) str) (all str Strs))

  (predicate (result-of (strlen str) num))

  (predicate (result-of (streq str str) bool))
  (predicate (result-of (strlt str str) bool))
  (predicate (result-of (strle str str) bool))
  (predicate (result-of (strgt str str) bool))
  (predicate (result-of (strge str str) bool))

  (predicate (result-of (strcieq str str) bool))
  (predicate (result-of (strcilt str str) bool))
  (predicate (result-of (strcile str str) bool))
  (predicate (result-of (strcigt str str) bool))
  (predicate (result-of (strcige str str) bool))

  (predicate (result-of (str2list str) (list char)))
  (predicate (result-of (str2num str) (maybe num)))
}

// STRING + STRING -> str
//
// Concatenate two strings
s1 + s2 = strcat(s1, s2)

// STRING[INDEX] -> char
//
// String element access
extern identifier!(string-ref)(str, num) -> char
s::str[k::num] = identifier!(string-ref)(s, k)

extern identifier!(substring) as __substring(str, num, num) -> str
substr(s str, start num, end num) = {
  if start < 0 then
    set start = length(s) + start
  if end < 0 then
    set end = length(s) + end
  return __substring(s, start, end)
}

s::str[r::range(num)] = substr(s, r#start, r#end)

extern identifier!(string-set!)(str, num, char) -> void
set s::str[k::num] = c = identifier!(string-set!)(s, k, c)


// STRING <cmp-op> STRING -> bool
//
// String comparison operators
s1 == s2 = streq(s1, s2)
s1 != s2 = not streq(s1, s2)
s1 < s2 = strlt(s1, s2)
s1 > s2 = strgt(s1, s2)
s1 <= s2 = strle(s1, s2)
s1 >= s2 = strge(s1, s2)

// lenght(STRING) -> num
//
// String length
length(s str) = strlen(s)

str(s str) = s
parse(s str) = Some(s)
list(s str) = str2list(s)
parse(s str) = str2num(s)
num(s str) = str2num(s).expect("Not a number")
extern identifier!(integer->char) as char(num) -> char
extern identifier!(char->integer) as num(char) -> num

// chomp(STRING) -> str
// chomp(STRING, SUFFIX) -> str
//
// If STRING ends with SUFFIX, then this procedure returns a copy of its first
// argument with the suffix removed, otherwise returns STRING unchanged.
// SUFFIX defaults to "\n".
extern identifier!(string-chomp) as chomp(str) -> str
extern identifier!(string-chomp) as chomp(str, str) -> str

join(it, sep str) =
  match next(it) in
  | Some(x) -> it.foldl(x, (acc, x) => acc + sep + x)
  | otherwize -> ""

