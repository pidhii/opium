
#pragma scheme-translator {
  (inline
    (import regex)

    (define osl_regexp regexp)

    (define (osl_string_match REGEXP STRING)
      (let ((match (string-match REGEXP STRING)))
        (if (not match)
            (maybe.Nothing)
            (maybe.Some (map (lambda (submatch) (or submatch "")) match)))))

    (define (osl_string_search REGEXP STRING)
      (let ((match (string-search REGEXP STRING)))
        (if (not match)
            (maybe.Nothing)
            (maybe.Some (map (lambda (submatch) (or submatch "")) match)))))

      (define (osl_string_split_fields REGEXP STRING)
        (string-split-fields REGEXP STRING #t))
    )

}

#pragma prolog {
  (predicate (result-of (osl_glob_to_regexp str) regexp))
  (predicate (result-of (osl_regexp str) regexp))

  (predicate (coerce str regexlike))
  (predicate (coerce regexp regexlike))
}

extern regexp(str) -> regexp

extern identifier!(string-match)(regexlike, str) -> list(str?)?
// TODO: expose via `=~`-operator

extern identifier!(string-search)(regexlike, str) -> list(str?)?
find(string str, pattern regexlike) =
  identifier!(string-search)(pattern, string)

extern identifier!(string-split-fields)(regexlike, str) -> list(str)
split(string str, pattern) =
  identifier!(string-split-fields)(pattern, string)
