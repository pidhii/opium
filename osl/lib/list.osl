require "base"


~~~
(import srfi-1)
~~~

#pragma match-translation-rule {
  (match-pattern . ((typename (list _)) _))
  (type-pattern . _)
  (predicate . (lambda (x) (or (pair? x) (null? x))))
  (unpack . identity)
}

list(l list(_)) = l

list(iter) = {
  assert { next(iter) :: maybe(_) }
  return reverse(iter.foldl([], (acc, x) => x : acc))
}

extern identifier!(list-ref) as identifier!(osl#ref)(list(T), num) -> T
extern identifier!(list-set!) as identifier!(osl#set)(list(T), num, T) -> void

extern length(list(_)) -> num

extern append as (+) (list(T), list(T)) -> list(T)

extern reverse(list(T)) -> list(T)

contains(l list(T), v T) = {
  extern identifier!(find-tail) as _find(fn(T) -> bool, list(T)) -> list(T)?
  return _find(x => x == v, l)
}


map(l list(T), f fn(T) -> U) = {
  extern map as builtin_map(fn(T) -> U, list(T)) -> list(U)
  return builtin_map(f, l)
}


foreach(l list(T), f fn(T) -> _) = {
  extern identifier!(for-each) as builtin_foreach(fn(T) -> _, list(T)) -> void
  builtin_foreach(f, l)
}

xs::list(T) == ys::list(T) =
  match xs, ys in
  | x : xs, y : ys -> x == y and xs == ys
  | [], [] -> true
  | otherwize -> false

xs::list(T) != ys::list(T) =
  match xs, ys in
  | x : xs, y : ys -> x != y or xs != ys
  | [], [] -> false
  | otherwize -> true


////////////////////////////////////////////////////////////////////////////////
//                           list - iterator
//
type listIterator(T) = { l list(T) }

iter(l list(_)) = listIterator(l)

next(it listIterator(_)) =
  match it#l in
  | x : xs -> { set it#l = xs Some(x) }
  | otherwize -> Nothing()

