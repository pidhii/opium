require "base"
require "coroutines"

~~~
(import srfi-12 (chicken condition))
~~~

extern identifier!(with-exception-handler)(fn(any) -> _, fn() -> T) -> T
extern abort(any) -> _
extern signal(any) -> any


// Scheme condition objects and their interface
#pragma prolog {
  (predicate (coerce property_condition condition))
  (predicate (coerce composite_condition condition))

  (predicate (result-of (make-property-condition _ . Properties) property_condition)
    (even-list Properties))

  (predicate (even-list ()))
  (predicate (even-list (_ _ . Xs))
    (even-list Xs))

  (predicate (result-of (make-composite-condition . Conditions) composite_condition)
    (all-less-then* fast-coerce Conditions condition))

  (predicate (result-of (condition-predicate _) (fn (any) bool)))
}

// Declare conditions and interface
extern identifier!(make-property-condition) as condition :: identifier!(make-property-condition)
c1::condition + c2::condition = {
  extern identifier!(make-composite-condition) :: identifier!(make-composite-condition)
  return identifier!(make-composite-condition)(c1, c2)
}
extern identifier!(condition-predicate) as condpredicate :: identifier!(condition-predicate)


// Convert try- and catch- clauses into a call to `with-exception-handler`,
// wrapped into a `call/cc` (in order to jump off the failed program thread).
//
// NOTE:
//   Result of call/cc will be a function that has to be imediately executed
//   (within the dynamic context from where the `try-catch` was used). In case
//   when exception was indeed raised, this function will execute the exception
//   handler. This way the exception handler can raise an exception on its own
//   without causing a non-terminal cycle of exception handling.
macro try {
  [
    try
      $expr:tryexpr
    catch $ident:exnvar
    $[| $expr:exnkind $[, $expr:k]*morekinds -> $expr:catchexpr]+catches
  ] = [
    let fin = callcc(__TryCont => 
      let handler($exnvar) =
            let dohandle() =
              $[
              if condpredicate($exnkind)($exnvar) $[and condpredicate($k)($exnvar)]morekinds then
                let $exnvar = reinterpret_cast($exnvar) :: condition in
                $catchexpr
              else
              ]catches
                abort($exnvar)
            in __TryCont(dohandle :: fn() -> T),
          thunk() = let result = $tryexpr in {() => result} :: fn() -> T
      in 
      identifier!(with-exception-handler)(handler, thunk))
    in fin()
  ]
  [
    try
      $expr:tryexpr
    catch $ident:exnvar ->
      $expr:catchexpr
  ] = [
    let fin = callcc(__TryCont => 
      let handler($exnvar) = __TryCont({() => $catchexpr} :: fn() -> T),
          thunk() = let result = $tryexpr in {() => result} :: fn() -> T
      in 
      identifier!(with-exception-handler)(handler, thunk))
    in fin()
  ]
  [
    try
      $expr:tryexpr
    catch
      $expr:catchexpr
  ] = [
    let fin = callcc(__TryCont => 
      let handler(_) = __TryCont({() => $catchexpr} :: fn() -> T),
          thunk() = let result = $tryexpr in {() => result} :: fn() -> T
      in 
      identifier!(with-exception-handler)(handler, thunk))
    in fin()
  ]
}


system_error = sym("exn")
type_error = sym("type")
arithmetic_error = sym("arithmetic")
io_error = sym("i/o")
file_error = sym("file")
net_error = sym("net")
bounds_error = sym("bounds")
runtime_error = sym("runtime")
limit_error = sym("limit")
match_error = sym("match")
syntax_error = sym("syntax")

get(x condition, kind, property, default) = {
  extern identifier!(condition-property-accessor)(any, any, any) -> any
  return identifier!(condition-property-accessor)(kind, property, default)(x)
}

get(x condition, kind, property) = {
  extern identifier!(condition-property-accessor)(any, any) -> any
  return identifier!(condition-property-accessor)(kind, property)(x)
}

properties(x condition) = generator {
  extern identifier!(condition->list)(condition) -> list(list(any))
  for cond in identifier!(condition->list)(x) do
  {
    if let condkind : properties = cond then
    {
      letrec yield_properties(properties) =
        if let propname : propval : properties = properties then
        {
          yield pack(condkind, propname, propval)
          yield_properties(properties)
        }
        else void()
      in yield_properties(properties)
    }
  }
}

error_message = sym("message")

what(cond condition, sep str) =
  cond.properties()
      .filter(x => let kind, prop, val = unpack(x) in equal(prop, error_message))
      .map(x => let kind, prop, val = unpack(x) in stringify(val))
      .join(sep, "")

what(cond condition) = what(cond, "; ")