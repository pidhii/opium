require "base"
require "string"
require "itertools"
require "error"


~~~
(import (chicken base) (chicken file posix) (chicken bitwise) (chicken io))

;; Map mode-characters to bit-flags
(define (char->open-flag char)
  (cond
    ((string=? char "r") open/read)
    ((string=? char "w") (+ open/write open/creat))
    ((string=? char "a") (+ open/append open/creat))
    ((string=? char "+") open/rdwr)
    ((string=? char "b") open/binary)
    ((string=? char "e") open/excl)
    (else (error "Invalid open-flag"))))

;; Open a file descriptor with flags decoded from the mode-string; and
;; then use this file descriptor to create a PORT object
(define (osl#open filename mode)
  (let* ((modechars (map string (string->list mode)))
          (modeflags (map char->open-flag modechars))
          (resflag (foldl + 0 modeflags))
          (fd (file-open filename resflag)))
    (if (= (bitwise-and open/write resflag) open/write)
        (if (= (bitwise-and open/append resflag) open/append)
            (open-output-file* fd #:append)
            (open-output-file* fd))
        (open-input-file* fd))))

(define osl_flush flush-output)
~~~


extern identifier!(osl#open) as open(str, str) -> port

close(p port) = {
  extern identifier!(input-port?)(port) -> bool
  extern identifier!(output-port?)(port) -> bool
  extern identifier!(close-input-port)(port) -> void
  extern identifier!(close-output-port)(port) -> void

  if identifier!(input-port?)(p) then
    identifier!(close-input-port)(p)
  else if identifier!(output-port?)(p) then
    identifier!(close-output-port)(p)
  else
    error("Invalid port", p)
}

////////////////////////////////////////////////////////////////////////////////
//                             writing
//
// Write string into a port
write(p port, s str) = {
  extern identifier!(write-string)(str, _, port) -> void
  identifier!(write-string)(s, false, p)
}

writeln(p port, s str) = {
  extern identifier!(write-line)(str, port) -> void
  identifier!(write-line)(s, p)
}

// Flush output port
extern identifier!(flush-output) as flush(port) -> void


////////////////////////////////////////////////////////////////////////////////
//                            reading
//
extern identifier!(eof-object?)(_) -> bool

// Read from port until EOF
read(port port) = {
  extern identifier!(read-string)(bool, port) -> str

  result = identifier!(read-string)(false, port)
  if identifier!(eof-object?)(result) then
    return Nothing
  else
    return Some(result)
}

// Read n bytes from port into a string
read(port port, n num) = {
  extern identifier!(read-string)(num, port) -> str

  result = identifier!(read-string)(n, port)
  if identifier!(eof-object?)(result) then
    return Nothing
  else
    return Some(result)
}


////////////////////////////////////////////////////////////////////////////////
//                            readline
//
readline(port) = {
  extern identifier!(read-line)(port) -> str

  line = identifier!(read-line)(port)
  if identifier!(eof-object?)(line) then
    return Nothing
  else
    return Some(line)
}


////////////////////////////////////////////////////////////////////////////////
//                       readline - iterator
//
type lines = { file port }
next(it lines) = readline(it#file)


////////////////////////////////////////////////////////////////////////////////
//                          string ports
//
// Input from a string
extern identifier!(open-input-string) as openstring(str) -> port

// Output into a string
extern identifier!(open-output-string) as openstring() -> ostringport
extern identifier!(get-output-string) as str(ostringport) -> str
#pragma prolog { (predicate (coerce ostringport port)) }
