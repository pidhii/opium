////////////////////////////////////////////////////////////////////////////////
//                              Syntax base
//
#pragma prolog { (ensure-loaded "prolog-std.scm") }

// Bool operations
bool(x bool) = x
#pragma prolog { (predicate (result-of (not bool) bool)) }

~~~
(import record-variants)
(import (chicken foreign))
~~~

// Void and values
#pragma prolog {
  (predicate (result-of (void) void))
  (predicate (result-of (values . Ts) . Ts))
}

// Meta assertion
#pragma prolog {
  (predicate (result-of (assert_thunk Thunk) Result)
    (if (result-of (Thunk) _)
        (= Result assertion_success)
        (= Result assertion_failure)))
}
~~~
(define (assert_thunk x) x)
~~~

// List
// o aliases for builtin `[ ... ]`-function
#pragma prolog {
  (predicate (result-of (osl#list . Ts) (list T)) (all T Ts))
}
~~~
(define osl#list list)
~~~
// o pattern matching
#pragma prolog {
  (predicate (result-of (list.Cons T (list T)) (list T)))
  (predicate (result-of (list.EmptyList) (list _)))
}

// Rules for matching on list
#pragma prolog {
  (predicate (match-on (osl#ctor#Cons T (list T)) (list T)))
  (predicate (match-on (osl#ctor#EmptyList) (list _)))
}

// Explicit coercion
#pragma prolog {
  (predicate (result-of (coerce T) U)
    (fast-coerce T U))
}
~~~
(define-compiler-syntax coerce
  (syntax-rules ()
    ((_ x) x)))
~~~

// Optional
~~~
(define osl#unspecified)

(define (osl#?->bool x)
  (and x (not (eq? x osl#unspecified))))

(define (osl#?* x)
  (if (osl#?->bool x) x (error osl#?* "dereferencing a nonvalue")))

(define-compiler-syntax osl#?*
  (syntax-rules ()
    ((_ x) (if (osl#?->bool x) x (error osl#?* "dereferencing a nonvalue")))))
~~~
#pragma prolog {
  (predicate (coerce T (? T)))
  (predicate (result-of (osl#?* (? T)) T))
  (predicate (result-of (osl#?->bool (? T)) bool))
}
(*)(x) = identifier!(osl#?*)(x) // TODO: investigate; pointeres become ambiguous
                                //       when type for `x` is specified
bool(x) = identifier!(osl#?->bool)(x)

// Type-classes
#pragma prolog {
  ;;;;
  ;; pattern-matching
  ;;;;
  (predicate (match-on ((typename T) T) U)
    (coerce T U))

  ;;;;;
  ;; (coerce T (or U1 U2 ...))
  ;;
  ;;     ∃ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (or U . Us))
    (if (fast-coerce T U) #t
        (coerce T (or . Us))))

  ;;;;
  ;; (coerce (or T1 T2 ...) U)
  ;;
  ;;     ∀ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (or . Ts) U)
    (all-less-then* fast-coerce Ts U))

  ;;;;
  ;; (coerce T (and U1 U2 ...))
  ;;
  ;;     ∀ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (and . Us))
    (less-then-all* fast-coerce T Us))

  ;;;;
  ;; (coerce (and T1 T2 ...) U)
  ;;
  ;;     ∃ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (and T . Ts) U)
    (if (fast-coerce T U) #t
        (coerce (and . Ts) U)))

  ;;;;
  ;;
  ;; (coerce T (not U))
  ;;
  ;;       ¬(T ≤ U)
  ;;;;
  (predicate (coerce T (not U))
    (not (fast-coerce T U)))
}

// Return expression (Bison misunderstands my intentions)
macro return {
  [return $expr:hd $[, $expr:e]*tl] = [__RETURN values($hd $[, $e]tl)]
  [return] = [__RETURN void()]
}

// Inline Scheme:
// o Allow calling results of inline-scheme expressions (does not produce any
//   type constraints).
#pragma prolog {
  (predicate (result-of (inline-scheme-result . Args) . Results))
}

////////////////////////////////////////////////////////////////////////////////
//                             parameters
//
#pragma prolog {
  (predicate (result-of ((parameter T) T) void))
  (predicate (result-of ((parameter T)) T))
}

////////////////////////////////////////////////////////////////////////////////
//                               cons-list
// type list(T) = Cons(T, list(T))
//              | EmptyList()
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Builtin Scheme functions for lists
  (predicate (result-of (car (list T)) T))
  (predicate (result-of (cdr (list T)) (list T)))
}
extern cons as (:) (T, list(T)) -> list(T)
//
// Auxiliary functions
~~~
(define (unpack-pair p) (values (car p) (cdr p)))
(define list.Cons cons)
(define (list.EmptyList) '())
~~~

//Rules for translation of cases expressions with list
#pragma match-translation-rule {
  (match-pattern . (osl#ctor#Cons _ _))
  (type-pattern . (list _))
  (predicate . pair?)
  (unpack . unpack-pair)
}
#pragma match-translation-rule {
  (match-pattern . (osl#ctor#EmptyList))
  (type-pattern . (list _))
  (predicate . null?)
  (unpack . void)
}



////////////////////////////////////////////////////////////////////////////////
//                              call/cc
//
extern identifier!(call-with-current-continuation) as callcc(fn(fn(T) -> U) -> T) -> T


////////////////////////////////////////////////////////////////////////////////
//                            Function classes
//
#pragma prolog {
  (predicate (result-of ((fn Args . Results) . InArgs) . Results)
    (coerce-list InArgs Args))
  (predicate (coerce Fn (fn Args . Results))
    (result-of (Fn . Args) . Results))
}


////////////////////////////////////////////////////////////////////////////////
//                              symbols
//
extern identifier!(string->symbol) as sym(str) -> sym
extern identifier!(symbol->string) as str(sym) -> str


////////////////////////////////////////////////////////////////////////////////
//                               meta
//
// Every iterator is also an *iterable*
iter(it) = {
  assert { next(it) :: maybe(T) }
  return it
}

// reinterpret_cast
~~~
(define-compiler-syntax reinterpret_cast
  (syntax-rules ()
    ((_ x) x)))
~~~
extern reinterpret_cast(_) -> _


////////////////////////////////////////////////////////////////////////////////
//                       builtin parameters
//
extern identifier!(exit-handler) as exit_handler :: fn(num) -> _
// extern identifier!(reset-handler) as reset_handler :: fn() -> _
// extern identifier!(program-name) as program_name :: str


////////////////////////////////////////////////////////////////////////////////
//                            ranges
//
type range(T) = {start T, end T}
(a::T) : (b::T) = range(a, b)
unpack(r range(T)) = values(r#start, r#end)


////////////////////////////////////////////////////////////////////////////////
//                           miscelanious
//
// Cut Prolog query
#pragma prolog { (predicate (result-of (cuttypecheck T) T) !) }
~~~
(define (cuttypecheck x) x)
~~~

