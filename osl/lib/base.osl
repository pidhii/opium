require "error"

////
//
// Builtin basic functions
//
#pragma prolog {
  (predicate (result-of (not _) bool))
  (predicate (result-of ((parameter T) T) void))
  (predicate (result-of ((parameter T)) T))
}

////
//
// Define cons-list:
//
//   type list(T) = Cons(T, list(T))
//                | EmptyList()
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Builtin Scheme functions for lists
  (predicate (result-of (car (list T)) T))
  (predicate (result-of (cdr (list T)) (list T)))
}
extern cons as (:) (T, list(T)) -> list(T)
//
#pragma scheme-translator {
  ;; Rules for translation of cases expressions with list
  (cases-rule (osl#ctor#Cons _ _) (list _) pair? unpack-pair)
  (cases-rule (osl#ctor#EmptyList) (list _) null? <unused>) ;; nothing to unpack

  ;; Inline auxiliary functions to avoid type-check and name mangling
  (inline
    (define (unpack-pair p) (values (car p) (cdr p)))
    (define list.Cons cons)
    (define (list.EmptyList) '())
  )
}


////////////////////////////////////////////////////////////////////////////////
//                              call/cc
//
extern identifier!(call-with-current-continuation) as callcc(fn(fn(T) -> U) -> U) -> U


////////////////////////////////////////////////////////////////////////////////
//                                maybe(T)
//
type maybe(T) = Some(T) | Nothing()

unpack(x maybe(T)) = match x in
| Some(value) -> value
| Nothing()   -> error("Unpack Nothing()")

expect(x maybe(T), message str) = match x in
| Some(value) -> value
| Nothing()   -> error(message)

unpack_or(x maybe(T), default T) = match x in
| Some(value) -> value
| Nothing()   -> default

bool(x maybe(T)) = match x in
| Some(value) -> true
| Nothing()   -> false


////////////////////////////////////////////////////////////////////////////////
//                              optionals
//
// null
#pragma prolog { (predicate (result-of (osl#null) (? _))) }
#pragma scheme-translator { (inline (define-inline (osl#null) #f)) }
macro null {[null] = [identifier!(osl#null)()]}

// maybe-like matching on optionals
#pragma prolog {
  (predicate (match-on (osl#ctor#Some T) (? T)))
  (predicate (match-on (osl#ctor#Nothing) (? T)))
}
#pragma scheme-translator {
  (cases-rule (osl#ctor#Some T) (? T) osl#?->bool identity)
}


////////////////////////////////////////////////////////////////////////////////
//                                 null
//



////////////////////////////////////////////////////////////////////////////////
//                            Function classes
//
#pragma prolog {
  (predicate (result-of ((fn Args Result) . Args) Result))
  (predicate (coerce Fn (fn Args . Results))
    (result-of (Fn . Args) . Results))
}


extern identifier!(string->symbol) as sym(str) -> sym
extern identifier!(symbol->string) as str(sym) -> str


////////////////////////////////////////////////////////////////////////////////
//                               meta
//
// Every iterator is also an *iterable*
iter(it) = {
  assert { next(it) :: maybe(T) }
  return it
}

// reinterpret_cast
#pragma scheme-translator {
  (inline
    (define-compiler-syntax reinterpret_cast
      (syntax-rules ()
        ((_ x) x))))
}
extern reinterpret_cast(_) -> _

// #pragma prolog { (predicate (coerce _ any)) }

// Type-case into `anything`
anything(x) = reinterpret_cast(x) :: anything


////////////////////////////////////////////////////////////////////////////////
//                       builtin parameters
//
extern identifier!(exit-handler) as exit_handler :: fn(num) -> _
// extern identifier!(reset-handler) as reset_handler :: fn() -> _
// extern identifier!(program-name) as program_name :: str


////////////////////////////////////////////////////////////////////////////////
//                            ranges
//
type range(T) = {start T, end T}
(a::T) : (b::T) = range(a, b)


////////////////////////////////////////////////////////////////////////////////
//                           miscelanious
//
// Cut Prolog query
#pragma prolog { (predicate (result-of (cuttypecheck T) T) !) }
#pragma scheme-translator { (inline (define (cuttypecheck x) x)) }

