////////////////////////////////////////////////////////////////////////////////
//                              Syntax base
//
#pragma prolog { (ensure-loaded "prolog-std.scm") }

// Bool operations
bool(x bool) = x
#pragma prolog { (predicate (result-of (not bool) bool)) }

#pragma scheme-translator {
  (inline
    (import record-variants)
    (import iterators)
    (import (chicken foreign)))
}

// Void and values
#pragma prolog {
  (predicate (result-of (void) void))
  (predicate (result-of (values . Ts) . Ts))
}

// Meta assertion
#pragma prolog {
  (predicate (result-of (assert_thunk Thunk) Result)
    (if (result-of (Thunk) _)
        (= Result assertion_success)
        (= Result assertion_failure)))
}
#pragma scheme-translator {
  (inline
    (define (assert_thunk x) x))
}

// List
// o aliases for builtin `[ ... ]`-function
#pragma prolog {
  (predicate (result-of (osl#list . Ts) (list T)) (all T Ts))
}
#pragma scheme-translator {
  (inline
    (define osl#list list))
}
// o pattern matching
#pragma prolog {
  (predicate (result-of (list.Cons T (list T)) (list T)))
  (predicate (result-of (list.EmptyList) (list _)))
}
identifier!(Cons)(a T, b list(T)) = identifier!(list.Cons)(a, b)
identifier!(EmptyList)() = identifier!(list.EmptyList)()

// Rules for matching on list
#pragma prolog {
  (predicate (match-on (osl#ctor#Cons T (list T)) (list T)))
  (predicate (match-on (osl#ctor#EmptyList) (list _)))

  (predicate (match-on ((typename T) T) T))
  (predicate (match-on ((typename T) T) (or . Ts))
    (member T Ts))
}

// Explicit coercion
#pragma prolog {
  (predicate (result-of (coerce T) U)
    (fast-coerce T U))
}
#pragma scheme-translator {
  (inline
    (define-compiler-syntax coerce
      (syntax-rules ()
        ((_ x) x))))
}

// Optional
#pragma scheme-translator {
  (inline
    (define osl#unspecified)
    (define (osl#?->bool x)
      (and x (not (eq? x osl#unspecified))))
    (define (osl#?* x)
      (if (osl#?->bool x) x (error osl#?* "dereferencing a nonvalue"))))
    (define-compiler-syntax osl#?*
      (syntax-rules ()
        ((_ x) (if (osl#?->bool x) x (error osl#?* "dereferencing a nonvalue")))))
}
#pragma prolog {
  (predicate (coerce T (? T)))
  (predicate (result-of (osl#?* (? T)) T))
  (predicate (result-of (osl#?->bool (? T)) bool))
}
(*)(x) = identifier!(osl#?*)(x) // TODO: investigate; pointeres become ambiguous
                                //       when type for `x` is specified
bool(x) = identifier!(osl#?->bool)(x)

// Unions/variants
#pragma prolog {
  ;;;;;
  ;; (coerce T (or U1 U2 ...))
  ;;
  ;;     ∃ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (or U . Us))
    (if (fast-coerce T U) #t
        (coerce T (or . Us))))

  ;;;;
  ;; (coerce (or T1 T2 ...) U)
  ;;
  ;;     ∀ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (or . Ts) U)
    (all-less-then* fast-coerce Ts U))

  ;;;;
  ;; (coerce T (and U1 U2 ...))
  ;;
  ;;     ∀ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (and . Us))
    (less-then-all* fast-coerce T Us))

  ;;;;
  ;; (coerce (and T1 T2 ...) U)
  ;;
  ;;     ∃ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (and T . Ts) U)
    (if (fast-coerce T U) #t
        (coerce (and . Ts) U)))

  ;;;;
  ;;
  ;; (coerce T (not U))
  ;;
  ;;       ¬(T ≤ U)
  ;;;;
  (predicate (coerce T (not U))
    (not (fast-coerce T U)))
}

// Return expression (Bison misunderstands my intentions)
macro return {
  [return $expr:hd $[, $expr:e]*tl] = [__RETURN values($hd $[, $e]tl)]
  [return] = [__RETURN void()]
}


////////////////////////////////////////////////////////////////////////////////
//                             parameters
//
#pragma prolog {
  (predicate (result-of ((parameter T) T) void))
  (predicate (result-of ((parameter T)) T))
}

////////////////////////////////////////////////////////////////////////////////
//                               cons-list
// type list(T) = Cons(T, list(T))
//              | EmptyList()
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Builtin Scheme functions for lists
  (predicate (result-of (car (list T)) T))
  (predicate (result-of (cdr (list T)) (list T)))
}
extern cons as (:) (T, list(T)) -> list(T)
//
#pragma scheme-translator {
  ;; Rules for translation of cases expressions with list
  (cases-rule (osl#ctor#Cons _ _) (list _) pair? unpack-pair)
  (cases-rule (osl#ctor#EmptyList) (list _) null? <unused>) ;; nothing to unpack

  ;; Inline auxiliary functions to avoid type-check and name mangling
  (inline
    (define (unpack-pair p) (values (car p) (cdr p)))
    (define list.Cons cons)
    (define (list.EmptyList) '())
  )
}


////////////////////////////////////////////////////////////////////////////////
//                              call/cc
//
extern identifier!(call-with-current-continuation) as callcc(fn(fn(T) -> U) -> T) -> T


////////////////////////////////////////////////////////////////////////////////
//                            Function classes
//
#pragma prolog {
  (predicate (result-of ((fn Args Result) . InArgs) Result)
    (coerce-list InArgs Args))
  (predicate (coerce Fn (fn Args . Results))
    (result-of (Fn . Args) . Results))
}


////////////////////////////////////////////////////////////////////////////////
//                              symbols
//
extern identifier!(string->symbol) as sym(str) -> sym
extern identifier!(symbol->string) as str(sym) -> str


////////////////////////////////////////////////////////////////////////////////
//                               meta
//
// Every iterator is also an *iterable*
iter(it) = {
  assert { next(it) :: maybe(T) }
  return it
}

// reinterpret_cast
#pragma scheme-translator {
  (inline
    (define-compiler-syntax reinterpret_cast
      (syntax-rules ()
        ((_ x) x))))
}
extern reinterpret_cast(_) -> _


////////////////////////////////////////////////////////////////////////////////
//                       builtin parameters
//
extern identifier!(exit-handler) as exit_handler :: fn(num) -> _
// extern identifier!(reset-handler) as reset_handler :: fn() -> _
// extern identifier!(program-name) as program_name :: str


////////////////////////////////////////////////////////////////////////////////
//                            ranges
//
type range(T) = {start T, end T}
(a::T) : (b::T) = range(a, b)
unpack(r range(T)) = values(r#start, r#end)


////////////////////////////////////////////////////////////////////////////////
//                           miscelanious
//
// Cut Prolog query
#pragma prolog { (predicate (result-of (cuttypecheck T) T) !) }
#pragma scheme-translator { (inline (define (cuttypecheck x) x)) }

