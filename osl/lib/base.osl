////////////////////////////////////////////////////////////////////////////////
//                              Syntax base
//
#pragma prolog { (ensure-loaded "prolog-std.scm") }

// Bool operations
bool(x bool) = x
#pragma prolog { (predicate (result-of (not bool) bool)) }
extern identifier!(not) :: identifier!(not) // FIXME: use scheme directly

~~~
(import record-variants)
(import (chicken foreign))
~~~

// Void and values
#pragma prolog {
  (predicate (result-of (void) void))
  (predicate (result-of (values . Ts) . Ts))
}
extern void :: void // FIXME: use scheme directly
extern values :: values

// Meta assertion
#pragma prolog {
  (predicate (result-of (assert_thunk Thunk) Result)
    (if (result-of (Thunk) _)
        (= Result assertion_success)
        (= Result assertion_failure)))
}
~~~
(define (assert_thunk x) x)
~~~

// List
// o aliases for builtin `[ ... ]`-function
~~~
(define osl#list list)
~~~
#pragma prolog {
  (predicate (result-of (osl#list . Ts) (list T)) (all T Ts))
}
extern identifier!(osl#list) :: identifier!(osl#list)

// o pattern matching
#pragma prolog {
  (predicate (match-on (osl#ctor#Cons T (list T)) (list T)))
  (predicate (match-on (osl#ctor#EmptyList) (list _)))
}

// Explicit coercion
#pragma prolog {
  (predicate (result-of (coerce T) U)
    (fast-coerce T U))
}
extern identity as coerce :: coerce

~~~
(define-compiler-syntax coerce
  (syntax-rules ()
    ((_ x) x)))
~~~


// Type-classes
#pragma prolog {
  ;;;;
  ;; pattern-matching
  ;;;;
  (predicate (match-on ((typename T) T) U)
    (fast-coerce T U))

  ;;;;;
  ;; (coerce T (or U1 U2 ...))
  ;;
  ;;     ∃ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (or . Us))
    (less-then-some* fast-coerce T Us))

  ;;;;
  ;; (coerce (or T1 T2 ...) U)
  ;;
  ;;     ∀ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (or . Ts) U)
    (all-less-then* fast-coerce Ts U))

  ;;;;
  ;; (coerce T (and U1 U2 ...))
  ;;
  ;;     ∀ Ui: T ≤ Ui
  ;;;;
  (predicate (coerce T (and . Us))
    (less-then-all* fast-coerce T Us))

  ;;;;
  ;; (coerce (and T1 T2 ...) U)
  ;;
  ;;     ∃ Ti: Ti ≤ U
  ;;;;
  (predicate (coerce (and . Ts) U)
    (some-less-then* fast-coerce Ts U))

  ;;;;
  ;;
  ;; (coerce T (not U))
  ;;
  ;;       ¬(T ≤ U)
  ;;;;
  (predicate (coerce T (not U))
    (not (fast-coerce T U)))
}

// Return expression (Bison misunderstands my intentions)
macro return {
  [return $expr:hd $[, $expr:e]*tl] = [__RETURN($hd $[, $e]tl)]
  [return] = [__RETURN()]
}

// Inline Scheme:
// o Allow calling results of inline-scheme expressions (does not produce any
//   type constraints).
#pragma prolog {
  (predicate (result-of (inline-scheme-result . Args) inline-scheme-result))
}


////////////////////////////////////////////////////////////////////////////////
//                        typename match translations
#pragma match-translation-rule {
  (match-pattern . ((typename num) _))
  (type-pattern . _)
  (predicate . number?)
  (unpack . identity)
}
#pragma match-translation-rule {
  (match-pattern . ((typename str) _))
  (type-pattern . _)
  (predicate . string?)
  (unpack . identity)
}
#pragma match-translation-rule {
  (match-pattern . ((typename sym) _))
  (type-pattern . _)
  (predicate . symbol?)
  (unpack . identity)
}
#pragma match-translation-rule {
  (match-pattern . ((typename bool) _))
  (type-pattern . _)
  (predicate . boolean?)
  (unpack . identity)
}
#pragma match-translation-rule {
  (match-pattern . ((typename char) _))
  (type-pattern . _)
  (predicate . character?)
  (unpack . identity)
}


////////////////////////////////////////////////////////////////////////////////
//                             parameters
//
#pragma prolog {
  (predicate (result-of ((parameter T) T) void))
  (predicate (result-of ((parameter T)) T))
}

////////////////////////////////////////////////////////////////////////////////
//                               cons-list
// type list(T) = Cons(T, list(T))
//              | EmptyList()
//
#pragma prolog {
  (ensure-loaded "prolog-std.scm")

  ;; Builtin Scheme functions for lists
  (predicate (result-of (car (list T)) T))
  (predicate (result-of (cdr (list T)) (list T)))
}
extern cons as (:) (T, list(T)) -> list(T)
//
// Auxiliary functions
~~~
(define (unpack-pair p) (values (car p) (cdr p)))
(define list.Cons cons)
(define (list.EmptyList) '())
~~~

//Rules for translation of cases expressions with list
#pragma match-translation-rule {
  (match-pattern . (osl#ctor#Cons _ _))
  (type-pattern . (list _))
  (predicate . pair?)
  (unpack . unpack-pair)
}
#pragma match-translation-rule {
  (match-pattern . (osl#ctor#EmptyList))
  (type-pattern . (list _))
  (predicate . null?)
  (unpack . void)
}



////////////////////////////////////////////////////////////////////////////////
//                              call/cc
//
extern identifier!(call-with-current-continuation) as callcc(fn(fn(T) -> U) -> T) -> T
extern identifier!(call-with-current-continuation) as __callcc(fn(fn(T) -> _) -> _) -> T


////////////////////////////////////////////////////////////////////////////////
//                            Function classes
//
#pragma prolog {
  (predicate (result-of ((fn Args . Results) . InArgs) . Results)
    (coerce-list InArgs Args))
  (predicate (coerce Fn (fn Args . Results))
    (result-of (Fn . Args) . Results))
}


////////////////////////////////////////////////////////////////////////////////
//                              symbols
//
extern identifier!(string->symbol) as sym(str) -> sym
extern identifier!(symbol->string) as str(sym) -> str


////////////////////////////////////////////////////////////////////////////////
//                               meta
//
// Every iterator is also an *iterable*
iter(it) = {
  assert { next(it) :: maybe(T) }
  return it
}

// reinterpret_cast
~~~
(define-inline (reinterpret_cast x) x)
~~~
extern reinterpret_cast(_) -> _


////////////////////////////////////////////////////////////////////////////////
//                       builtin parameters
//
extern identifier!(exit-handler) as exit_handler :: fn(num) -> _
// extern identifier!(reset-handler) as reset_handler :: fn() -> _
// extern identifier!(program-name) as program_name :: str


////////////////////////////////////////////////////////////////////////////////
//                            ranges
//
type range(T) = {start T, end T}
(a::T) : (b::T) = range(a, b)
unpack(r range(T)) = values(r#start, r#end)


////////////////////////////////////////////////////////////////////////////////
//                           miscelanious
//
// Cut Prolog query
#pragma prolog { (predicate (result-of (cuttypecheck T) T) !) }
~~~
(define (cuttypecheck x) x)
~~~

// any: unique type that anything coerces to
#pragma prolog {
  (predicate (coerce T any))
}
extern identifier!(equal?) as equal(any, any) -> bool
extern identifier!(->string) as stringify(any) -> str
