
macro for {
  // ---------------------------------------------------------------------------
  // Zipping for-loops
  // ---------------------------------------------------------------------------
  [
    for $ident:head $[, $ident:ident]+tail in $expr:shead $[, $expr:seq]+stail do
      $expr:body
    else
      $expr:fin
  ] = [
    // will use identifiers of loop variables also as identifiers for iterators
    let $head $[, $ident]tail = values(iter($shead) $[, iter($seq)]stail) in
    callcc(__LoopExit =>
      letrec __Loop() =
        // loop will stop when some iterator doesn't return `Some()`
        match next($head) $[, next($ident)]tail in
        | Some($head) $[, Some($ident)]tail -> { $body __Loop() }
        | otherwize -> { $fin void() }
      in __Loop()
    )
  ]
  [
    for $ident:head $[, $ident:ident]+tail in $expr:shead $[, $expr:seq]+stail do
      $expr:body
  ] = [
    callcc(__LoopExit =>
      let $head $[, $ident]tail = values(iter($shead) $[, iter($seq)]stail) in
      letrec __Loop() =
        match next($head) $[, next($ident)]tail in
        | Some($head) $[, Some($ident)]tail -> { $body __Loop() }
        | otherwize -> void()
      in __Loop()
    )
  ]

  // ---------------------------------------------------------------------------
  // For-loops over iterables with implicit `unpack()`
  // ---------------------------------------------------------------------------
  [
    for $ident:head $[, $ident:ident]+tail in $expr:seq do
      $expr:body
    else
      $expr:fin
  ] = [
    callcc(__LoopExit =>
      let __LoopIt = iter($seq) in
      letrec __Loop() =
        match next(__LoopIt) in
        | Some(__LoopVal) ->
            let $head $[, $ident]tail = unpack(__LoopVal) in
            { $body __Loop() }
        | otherwize -> { $fin void() }
      
      in __Loop()
    )
  ]
  [
    for $ident:head $[, $ident:ident]+tail in $expr:seq do
      $expr:body
  ] = [
    callcc(__LoopExit =>
      let __LoopIt = iter($seq) in
      letrec __Loop() =
        match next(__LoopIt) in
        | Some(__LoopVal) ->
            let $head $[, $ident]tail = unpack(__LoopVal) in
            { $body __Loop() }
        | otherwize -> void()
      in __Loop()
    )
  ]

  // ---------------------------------------------------------------------------
  // Simple for loops over iterables
  // ---------------------------------------------------------------------------
  [
    for $ident:x in $expr:seq do
      $expr:body
    else
      $expr:fin
  ] = [
    callcc(__LoopExit =>
      let __LoopIt = iter($seq) in
      letrec __Loop() =
        match next(__LoopIt) in
        | Some($x) -> { $body __Loop() }
        | otherwize -> { $fin void() }
      in __Loop()
    )
  ]
  [
    for $ident:x in $expr:seq do
      $expr:body
  ] = [
    callcc(__LoopExit =>
      let __LoopIt = iter($seq) in
      letrec __Loop() =
        match next(__LoopIt) in
        | Some($x) -> { $body __Loop() }
        | otherwize -> void()
      in __Loop()
    )
  ]
}

macro while {
  // Loops conditioned on pattern matching with optional else-clause
  [
    while let $expat:condpat = $expr:condexpr do
      $expr:body
    else
      $expr:fin
  ] = [
    callcc(__LoopExit =>
      letrec __Loop() =
        match $condexpr in
        | $condpat -> { $body __Loop() }
        | otherwize -> { $fin void() }
      in __Loop()
    )
  ]
  [
    while let $expat:condpat = $expr:condexpr do
      $expr:body
  ] = [
    callcc(__LoopExit => 
      letrec __Loop() =
        match $condexpr in
        | $condpat -> { $body __Loop() }
        | otherwize -> void()
      in __Loop()
    )
  ]
  // While loops with optional else-clause
  [
    while $expr:cond do
      $expr:body
    else
      $expr:fin
  ] = [
    callcc(__LoopExit =>
      letrec __Loop() =
        if $cond then { $body __Loop() }
        else { $fin void() }
      in __Loop()
    )
  ]
  [while $expr:cond do $expr:body] = [
    callcc(__LoopExit =>
      letrec __Loop() =
        if $cond then { $body __Loop() }
        else void()
      in __Loop()
    )
  ]
}

macro continue {[continue] = [__LoopExit(__Loop())]}
macro break {[break] = [__LoopExit(void())]}
