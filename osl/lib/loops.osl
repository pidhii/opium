
macro for {
  // ---------------------------------------------------------------------------
  // Zipping for-loops
  // ---------------------------------------------------------------------------
  [
    for $ident:head $[, $ident:ident]+tail in $expr:shead $[, $expr:seq]+stail do
      $expr:body
    else
      $expr:fin
  ] = [
    // will use identifiers of loop variables also as identifiers for iterators
    let $head $[, $ident]tail = values(iter($shead) $[, iter($seq)]stail) in
    letrec __Loop() = {
      // loop will stop when some iterator doesn't return `Some()`
      match next($head) $[, next($ident)]tail in
      | Some($head) $[, Some($ident)]tail -> { $body __Loop() }
      | otherwize -> $fin
    }
    in __Loop()
  ]
  [
    for $ident:head $[, $ident:ident]+tail in $expr:shead $[, $expr:seq]+stail do
      $expr:body
  ] = [
    let $head $[, $ident]tail = values(iter($shead) $[, iter($seq)]stail) in
    letrec __Loop() = {
      match next($head) $[, next($ident)]tail in
      | Some($head) $[, Some($ident)]tail -> { $body __Loop() }
    }
    in __Loop()
  ]

  // ---------------------------------------------------------------------------
  // For-loops over iterables with implicit `unpack()`
  // ---------------------------------------------------------------------------
  [
    for $ident:head $[, $ident:ident]+tail in $expr:seq do
      $expr:body
    else
      $expr:fin
  ] = [
    let __Loop_It = iter($seq) in
    letrec __Loop() = {
      match next(__Loop_It) in
      | Some(__Loop_Val) ->
          let $head $[, $ident]tail = unpack(__Loop_Val) in
          { $body __Loop() }
      | otherwize -> $fin
    }
    in __Loop()
  ]
  [
    for $ident:head $[, $ident:ident]+tail in $expr:seq do
      $expr:body
  ] = [
    let __Loop_It = iter($seq) in
    letrec __Loop() = {
      match next(__Loop_It) in
      | Some(__Loop_Val) ->
          let $head $[, $ident]tail = unpack(__Loop_Val) in
          { $body __Loop() }
    }
    in __Loop()
  ]

  // ---------------------------------------------------------------------------
  // Simple for loops over iterables
  // ---------------------------------------------------------------------------
  [
    for $ident:x in $expr:seq do
      $expr:body
    else
      $expr:fin
  ] = [
    let __Loop_It = iter($seq) in
    letrec __Loop() = {
      match next(__Loop_It) in
      | Some($x) -> { $body __Loop() }
      | otherwize -> $fin
    }
    in __Loop()
  ]
  [
    for $ident:x in $expr:seq do
      $expr:body
  ] = [
    let __Loop_It = iter($seq) in
    letrec __Loop() = {
      match next(__Loop_It) in
      | Some($x) -> { $body __Loop() }
    }
    in __Loop()
  ]
}

macro while {
  // Loops conditioned on pattern matching with optional else-clause
  [while let $expat:condpat = $expr:condexpr do $expr:body else $expr:fin] = [
    letrec __Loop() = {
      match $condexpr in
      | $condpat -> { $body __Loop() }
      | otherwize -> $fin
    }
    in __Loop()
  ]
  [while let $expat:condpat = $expr:condexpr do $expr:body] = [
    letrec __Loop() = {
      match $condexpr in
      | $condpat -> { $body __Loop() }
    }
    in __Loop()
  ]
  // While loops with optional else-clause
  [while $expr:cond do $expr:body else $expr:fin] = [
    letrec __Loop() = {
      if $cond then
      {
        $body
        __Loop()
      }
      else
        $fin
    }
    in __Loop()
  ]
  [while $expr:cond do $expr:body] = [
    letrec __Loop() = {
      if $cond then
      {
        $body
        __Loop()
      }
    }
    in __Loop()
  ]
}

macro continue {[continue] = [return __Loop()]}
macro break {[break] = [{ return }]}
