require "base"

// TODO:
// The 'iterators' library used here is crap as it iterates the coroutine past
// the yield (and till the subsequent yeld) while returning value of the first
// yield. Consequently, functions that rely on execution state AT yeld can't use
// it (and are very funny to debug).
//
// So change the backend or implement it yourself (be a man).

#pragma scheme-translator {
  (inline
    (import iterators)
    (define co_value co-value)
    (define co_move co-move)
    (define co_finished co-finished?))
}
#pragma prolog {
  (predicate (result-of (coroutine Fn) (coroutine T))
    (result-of (Fn (fn (T) void)) void))
  (predicate (result-of (co_value (coroutine T)) T))
  (predicate (result-of (co_move (coroutine T)) (coroutine T)))
  (predicate (result-of (co_finished (coroutine _)) bool))
}

type generator(T) = {
  co coroutine(T)
}

generator(f) = generator(coroutine(f))

next(gen generator(T)) = {
  co = gen#co
  if co_finished(co) then
    return Nothing()
  else {
    set gen#co = co_move(co)
    return Some(co_value(co))
  }
}

macro generator {
  [generator {] = [generator(__Generator_yield => { __Generator]
}
macro __Generator {
  [__Generator }] = [})]
  [__Generator $stmt:stmt] = [$stmt __Generator]
}
macro yield {
  [yield $expr:expr] = [__Generator_yield($expr)]
}

