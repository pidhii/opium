require "base"

// TODO:
// The 'iterators' library used here is crap as it iterates the coroutine past
// the yield (and till the subsequent yeld) while returning value of the first
// yield. Consequently, functions that rely on execution state AT yeld can't use
// it (and are very funny to debug).
//
// So change the backend or implement it yourself (be a man).

~~~
(import iterators)
~~~

extern coroutine as generator_co(fn(fn(T) -> void) -> _) -> generator_co(T)
extern identifier!(co-value) as co_value(generator_co(T)) -> T
extern identifier!(co-move) as co_move(generator_co(T)) -> generator_co(T)
extern identifier!(co-finished?) as co_finished(generator_co(T)) -> bool

type generator(T) = { co generator_co(T) }
generator(f) = generator(generator_co(f))

next(gen explicit generator(T)) = {
  co = gen#co
  if co_finished(co) then
    return Nothing
  else {
    set gen#co = co_move(co)
    return Some(co_value(co))
  }
}

macro generator {
  [generator {] = [generator(__Generator_yield => { __Generator]
}
macro __Generator {
  [__Generator }] = [})]
  [__Generator $stmt:stmt] = [$stmt __Generator]
}
macro yield {
  [yield $expr:expr] = [__Generator_yield($expr)]
}
