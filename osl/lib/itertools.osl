require "base"
require "error"
require "number"


////////////////////////////////////////////////////////////////////////////////
//                             iteration
//
foreach(it, f fn(T) -> _) = match next(it) in
| Some(x) -> { f(x) foreach(it, f) }
| Nothing -> void()


foldl(it, z T, f fn(T, U) -> T) = match next(it) in
| Some(x) -> foldl(it, f(z, x), f)
| Nothing -> z

join(it, sep) =
  match next(it) in
  | Some(x) -> it.foldl(x, (acc, xx) => acc + sep + xx)
  | Nothing -> error("Can't join empty sequence")

join(it, sep, default) =
  match next(it) in
  | Some(x) -> it.foldl(x, (acc, xx) => acc + sep + xx)
  | Nothing -> default


/////////////////////////////////////////////////////////////////////////////////
//                                search
//
find(it, p fn(_) -> bool) = match next(it) in
| Some(x) -> if p(x) then Some(x) else find(it, p)
| Nothing -> Nothing


////////////////////////////////////////////////////////////////////////////////
//                           map - iterator
//
type map(Iter, T, U) = {
  inner Iter,
  func fn(T) -> U,
}

next(it map(_, _, _)) =
  match next(it#inner) in
  | Some(x) -> Some(it#func(x))
  | Nothing -> Nothing


////////////////////////////////////////////////////////////////////////////////
//                           while - iterator
//
type takewhile(Iter, T) = {
  inner Iter,
  pred fn(T) -> bool,
  isdone bool,
}

next(it takewhile(Iter, T)) =
  if it#isdone then Nothing
  else match next(it#inner) in
  | Some(x) -> if it#pred(x) then Some(x) else { set it#isdone = true Nothing }
  | Nothing -> Nothing

take(it, p) = takewhile(it, p, false)


////////////////////////////////////////////////////////////////////////////////
//                           take - iterator
//
type take(Iter) = {
  inner Iter,
  n num,
}

next(it take(_)) =
  let n = it#n in
  if n <= 0 then Nothing
  else if let Some(x) = next(it#inner) then { set it#n = n - 1 Some(x) }
  else { set it#n = 0 Nothing }


////////////////////////////////////////////////////////////////////////////////
//                                 drop
//
drop(it, n num) =
  if n <= 0 then { next(it) drop(it, n - 1) }
  else it


////////////////////////////////////////////////////////////////////////////////
//                         filter - iterator
//
type filter(Iter, T) = {
  inner Iter,
  pred  fn(T) -> bool,
}

next(it filter(_, _)) =
  match next(it#inner) in
  | Some(x) -> if it#pred(x) then Some(x) else next(it)
  | Nothing -> Nothing


////////////////////////////////////////////////////////////////////////////////
//                         range - iterator
//
type rangeiter(T) = { start T, end T }

iter(r range(T)) = rangeiter(r#start, r#end)

next(it rangeiter(T)) =
  let result = it#start in
  if result < it#end then
  {
    set it#start = result + 1
    Some(result)
  }
  else
    Nothing


////////////////////////////////////////////////////////////////////////////////
//                        enumerate - iterator
//
type enumerate(Iter) = {
  inner Iter,
  counter num,
}

enumerate(it) = enumerate(it, 0)

next(it enumerate(_)) =
  if let Some(x) = next(it#inner) then
  {
    result = Some(pack(it#counter, x))
    set it#counter = it#counter + 1
    result
  }
  else
    Nothing
