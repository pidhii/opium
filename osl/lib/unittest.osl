require "vector"
require "loops"
require "exceptions"


type unit_test_fixtures = { }


type unit_tests_t = {
  tests dict(str, fn() -> void)
}

add(self unit_tests_t, testname str, test fn() -> void) = {
  set self#tests[testname] = test
}

run(self unit_tests_t) = {
  println("\e[38;5;5;1munit tests\e[0m")
  for testname, test in self#tests do {
    printstatus(statustext) = {
      print("\r[", statustext, "] ", testname)
      flush(stdout)
    }

    printstatus(" ")
    try {
      test()
      printstatus("\e[38;5;2;1mâœ“\e[0m")
      println()
    }
    catch exn
    | test_failure -> {
      printstatus("\e[38;5;1;1mâœ—\e[0m")
      println("")
      for _kind, prop, val in exn.properties() do
        println("  \e[2m", prop, ": ", val, "\e[0m")
    }
    | system_error -> {
      printstatus("\e[38;5;1;1mâœ—\e[0m")
      println(" \e[2m-> ", exn, ": ", what(exn), "\e[0m")
    }
  }
}

test_failure = sym("test-failure")

macro unit_test_fixture {
  [unit_test_fixture $ident:fixture_name($ident:fixture $[, $ident:f]*fixrest) = $expr:init_expr] = [
    fixtures#$fixture_name =
        let $fixture = fixtures#$fixture $[, $f = fixtures#$f]fixrest in
        $init_expr
  ]
  [unit_test_fixture $ident:fixture_name = $expr:init_expr] = [
    fixtures#$fixture_name = $init_expr
  ]
}

macro unit_test {
  [unit_test $ident:test_name ($ident:fixture $[, $ident:f]*fixrest) = $expr:test_body] = [
    unit_tests.add($#test_name, () => {
      let $fixture = fixtures#$fixture $[, $f = fixtures#$f]fixrest in
      $test_body
      void()
    })
  ]
  [unit_test $ident:test_name = $expr:test_body] = [
    unit_tests.add($#test_name, () => { $test_body void() })
  ]
}

// FIXME
infinity = reinterpret_cast(scm { +inf.0 }) :: num
macro test_equal_seqs {
  [test_equal_seqs $expr:lhs = $expr:rhs] = [
    let __cntiter = iter(0 : infinity),
        __lhsiter = iter($lhs),
        __rhsiter = iter($rhs)
    in
    {
      // Check equality element by element
      letrec loop() = match next(__cntiter), next(__lhsiter), next(__rhsiter) in
      | Some(i), Some(lhs), Some(rhs) ->
        if not equal(lhs, rhs) then
            let exn = condition(test_failure,
                                error_message, "Sequences are not equal",
                                "index", i,
                                "lhs", lhs,
                                "rhs", rhs)
            in abort(exn)
        else loop()
      | Some(i), Some(lhs), _ ->
        let exn = condition(test_failure,
                            error_message, "Sequences differ in length",
                            "lhs-tail", lhs : list(__lhsiter))
        in abort(exn)
      | Some(i), _, Some(rhs) ->
        let exn = condition(test_failure,
                            error_message, "Sequences differ in length",
                            "rhs-tail", rhs : list(__rhsiter))
        in abort(exn)
      | otherwize -> void()
      in loop()
    }
  ]
}

macro test_equal {
  [test_equal $expr:lhs = $expr:rhs] = [
    let lhs = $lhs, rhs = $rhs in
    if not equal(lhs, rhs) then
      let exn = condition(test_failure,
                          error_message, "Values not equal",
                          "lhs", lhs,
                          "rhs", rhs)
      in abort(exn)
  ]
}

macro test_note_equal {
  [test_note_equal $expr:lhs = $expr:rhs] = [
    let lhs = $lhs, rhs = $rhs in
    if equal(lhs, rhs) then
      let exn = condition(test_failure,
                          error_message, "Values equal",
                          "lhs", lhs,
                          "rhs", rhs)
      in abort(exn)
  ]
}

macro test_eq {
  [test_eq $expr:lhs = $expr:rhs] = [
    let lhs = $lhs, rhs = $rhs in
    if not eq(lhs, rhs) then
      let exn = condition(test_failure,
                          error_message, "Values not eq",
                          "lhs", lhs,
                          "rhs", rhs)
      in abort(exn)
  ]
}

macro test_not_eq {
  [test_not_eq $expr:lhs = $expr:rhs] = [
    let lhs = $lhs, rhs = $rhs in
    if eq(lhs, rhs) then
      let exn = condition(test_failure,
                          error_message, "Values eq",
                          "lhs", lhs,
                          "rhs", rhs)
      in abort(exn)
  ]
}



macro test_true {
  [test_true $expr:expr] = [
    let res = $expr in
    if not res then
      let exn = condition(test_failure,
                          error_message, "Not true",
                          "value", res)
      in abort(exn)
  ]
}

macro test_false {
  [test_true $expr:expr] = [
    let res = $expr in
    if res then
      let exn = condition(test_failure,
                          error_message, "Not false",
                          "value", res)
      in abort(exn)
  ]
}

macro test_match {
  [test_match $expr:expr = $expat:pat] = [
    match $expr in
    | $pat -> void()
    | value ->
      let exn = condition(test_failure,
                          error_message, "Does not match",
                          "value", value)
      in abort(exn)
  ]
}


fixtures = unit_test_fixtures()
unit_tests = unit_tests_t(dict())

scm { on-exit }(run_tests :: fn() -> void)
where run_tests = () => unit_tests.run()