#!/usr/bin/env -S ./install/bin/opium-osl -v -R

require "memory"
require "coroutines"


```C
#include <unistd.h>

static void
setoptind(int ind)
{ optind = ind; }

static int
getoptind()
{ return optind; }

static char*
getoptarg()
{ return optarg; }
```


getopt(argv, optstring str) = {
  // int getopt(int argc, char *argv[], const char *optstring);
  extern foreign getopt as c_getopt(int, char**, cstr) -> int
  extern foreign setoptind(int) -> void
  extern foreign getoptind() -> int
  extern foreign getoptarg() -> cstr

  // Allocate strings on the heap to pass them into C
  argc = length(argv)
  argvp = allocate((argc + 1) * 8) :: ptr(ptr(i8))
  for i in 0 : argc do
    set argvp[i] = strdup(argv[i])
  set argvp[argc] = ptr(0)

  // Force getopt to start from scratch
  setoptind(0)

  // Run getopt()
  opts = dict()
  while true do {
    opt = c_getopt(argc, argvp, optstring)
    if opt < 0 then
      break
    set opts[opt] = getoptarg()
  }

  // Collect remaining elements of argv as positional arguments
  args = list(argv.iter().drop(getoptind()))

  // NOTE: Releasing memory results in subsequent calls to (c_)getopt to produce
  // garbage. Resetting `optind` does not help. As the observed behaviour is 
  // undefined / undocumented we will not try to do any backflip deferred
  // dealocations and let the memory leak. Noramlly, `getopt` is only called a
  // finite number of times per program (usually once), thus the introduced
  // memory leak should not matter.
  // for i in 0 : argc do
  //   free(argvp[i])
  // free(argvp)

  return opts, args
}