require "io"

type json = JsonStructure(dict(str, json))
          | JsonArray(list(json))
          | JsonNumber(num)
          | JsonString(str)
          | JsonNull
          

#pragma scheme-translator {
  (inline
    (import json)

    (define (scm->json obj)
      (cond ((vector? obj)
              (let* ((objl (vector->list obj))
                     (kv->json (lambda (kv) (cons (car kv) (scm->json (cdr kv)))))
                     (newlist (map kv->json objl)))
                (json.JsonStructure (alist->hash-table newlist))))
            ((pair? obj) (json.JsonArray (map scm->json obj)))
            ((null? obj) (json.JsonArray obj))
            ((number? obj) (json.JsonNumber obj))
            ((string? obj) (json.JsonString obj))
            (else (error "Unsupported JSON object" obj))))

    (define (json->scm obj)
      (cond ((json.JsonStructure? obj)
              (let* ((hashtable (json.JsonStructure-:0 obj))
                     (alist (hash-table-map hashtable
                              (lambda (key val) (cons key (json->scm val)))))
                     (avec (list->vector alist)))
                avec))
            ((json.JsonArray? obj) (map json->scm (json.JsonArray-:0 obj)))
            ((json.JsonNull? obj) (void))
            ((json.JsonNumber? obj) (json.JsonNumber-:0 obj))
            ((json.JsonString? obj) (json.JsonString-:0 obj))
            (else obj)))


    (define (read_json port)
      (let ((obj (json-read port)))
        (scm->json obj)))

    (define (write_json PORT JSON)
      (json-write (json->scm JSON) PORT))
  )
}
#pragma prolog {
  (predicate (result-of (read_json port) json))
  (predicate (result-of (write_json port _) void))
}

// read_json(port)
parse_json(s str) = call_with_input_string(s, read_json) :: json

json() = JsonStructure(dict())
json(x json) = x
json(x num) = JsonNumber(x)
json(x str) = JsonString(x)
json(x list(T)) = JsonArray(x.iter().map(json).list())
json(x dict(str, T)) = {
  newdict = dict() :: dict(str, json)
  x.keys().foreach(key => set newdict[key] = json(x[key]))
  return JsonStructure(newdict)
}

// num
num(j json) = match j in
| JsonNumber(x) -> x
| otherwize -> error("Not a number", j)

// str
str(j json) = match j in
| JsonString(x) -> x
| otherwize -> error("Not a string", j)

// list(T)
list(j json) = match j in
| JsonArray(x) -> x
| otherwize -> error("Not a list", j)

// dict(str, json)
dict(j json) = match j in
| JsonStructure(x) -> x
| otherwize -> error("Not a structure", j)

// Element getters
json_ref(j json, k str) = j.dict()[k]
json_ref(j json, k num) = j.list()[k]
j[k] = json_ref(j, k)

// Element setters
json_set(j json, k str, v) = set j.dict()[k] = json(v)
json_set(j json, k num, v) = set j.list()[k] = json(v)
set j[k] = v = json_set(j, k, v)
